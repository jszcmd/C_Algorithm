/*
 * ğŸŒ² é¢˜ç›®åç§°: P3366 ã€æ¨¡æ¿ã€‘æœ€å°ç”Ÿæˆæ ‘
 * ğŸ”— é¢˜ç›®æ¥æº: æ´›è°· (Luogu)
 * ğŸš€ ç®—æ³•æ ‡ç­¾: Kruskal / å¹¶æŸ¥é›† / å›¾è®º
 * #### æµ‹è¯•é“¾æ¥: https://www.luogu.com.cn/problem/P3366
 * ğŸ“ é¢˜ç›®æè¿°
 * ----------------------------------------------------
 * å¦‚é¢˜,ç»™å‡ºä¸€ä¸ªæ— å‘å›¾,æ±‚å‡ºæœ€å°ç”Ÿæˆæ ‘.
 * å¦‚æœè¯¥å›¾ä¸è¿é€š,åˆ™è¾“å‡º "orz".
 *
 * ğŸ“¥ è¾“å…¥æ ¼å¼
 * ----------------------------------------------------
 * 1. ç¬¬ä¸€è¡Œ:ä¸¤ä¸ªæ•´æ•° N, M (N ä¸ªç»“ç‚¹ï¼ŒM æ¡è¾¹)
 * 2. åç»­ M è¡Œ:æ¯è¡Œä¸‰ä¸ªæ•´æ•° Xi, Yi, Zi
 * (è¡¨ç¤ºæœ‰ä¸€æ¡é•¿åº¦ä¸º Zi çš„æ— å‘è¾¹è¿æ¥ç»“ç‚¹ Xi, Yi)
 *
 * ğŸ“¤ è¾“å‡ºæ ¼å¼
 * ----------------------------------------------------
 * âœ… è‹¥è¿é€š:è¾“å‡ºä¸€ä¸ªæ•´æ•°,è¡¨ç¤ºæœ€å°ç”Ÿæˆæ ‘çš„è¾¹æƒä¹‹å’Œ.
 * âŒ è‹¥ä¸è¿é€š:è¾“å‡º "orz".
 *
 * ğŸ§ æ ·ä¾‹æ•°æ®
 * ----------------------------------------------------
 * Input:                  Output:
 * 4 5                     7
 * 1 2 2
 * 1 3 2
 * 1 4 3
 * 2 3 4
 * 3 4 3
 *
 * ğŸ“Š æ•°æ®èŒƒå›´
 * ----------------------------------------------------
 * ğŸ”¹ N <= 5,000
 * ğŸ”¹ M <= 200,000
 * ğŸ”¹ Zi <= 10,000
 */

#include <stdlib.h>  // ğŸ› ï¸ malloc() / free()
#include <stdbool.h> // ğŸŸ¢ bool ç±»å‹
#include <stdio.h>   // ğŸ“¥ scanf() / printf()

#define MAXN 5001   // ğŸ”¢ æœ€å¤§èŠ‚ç‚¹æ•° (N)
#define MAXM 400001 // ğŸ›£ï¸ æœ€å¤§è¾¹æ•° (M, å»ºè®®å¼€å¤§ä»¥é˜²è¶Šç•Œ)

// =====================================================================================================
// 1ï¸âƒ£ é‚»æ¥è¡¨å»ºå›¾ (Adjacency List Construction)
// =====================================================================================================

struct EdgeNode
{
    int to;                // ğŸ¯ ç›®æ ‡èŠ‚ç‚¹ ID
    int weight;            // âš–ï¸ è¾¹çš„æƒé‡ (Cost)
    struct EdgeNode *next; // â¡ï¸ ä¸‹ä¸€æ¡è¾¹çš„æŒ‡é’ˆ
};

typedef struct EdgeNode EdgeNode;

EdgeNode *adjList[MAXN]; // ğŸ“ é‚»æ¥è¡¨å¤´æŒ‡é’ˆæ•°ç»„
int n, m;                // ğŸ“ n:èŠ‚ç‚¹æ•°, m:è¾¹æ•°

// ğŸ—ï¸ åˆå§‹åŒ–å›¾ç»“æ„ (æ¸…ç†æ—§å†…å­˜ + é‡ç½®å¤´æŒ‡é’ˆ)
void build(int n)
{
    for (int i = 0; i <= n; i++) // ğŸ”„ éå† 0~n (é˜²æ­¢èŠ‚ç‚¹ç¼–å·è¶Šç•Œ),æˆ‘ä»¬åªç”¨åˆ°1-n
    {
        EdgeNode *cur = adjList[i];
        while (cur) // ğŸ§¹ éå†é“¾è¡¨æ¸…ç†æ—§å†…å­˜
        {
            EdgeNode *temp = cur;
            cur = cur->next;
            free(temp); // ğŸ—‘ï¸ é‡Šæ”¾èŠ‚ç‚¹å†…å­˜
        }
        adjList[i] = NULL; // ğŸš« å¤´æŒ‡é’ˆç½®ç©º
    }
}

// â• æ·»åŠ è¾¹åˆ°é‚»æ¥è¡¨ (å¤´æ’æ³• O(1))
void addListEdge(int u, int v, int w)
{
    EdgeNode *newNode = (EdgeNode *)malloc(sizeof(EdgeNode));
    newNode->to = v;            // ğŸ“ è®°å½•ç»ˆç‚¹
    newNode->weight = w;        // âš–ï¸ è®°å½•æƒé‡
    newNode->next = adjList[u]; // ğŸ”— æ¥å…¥é“¾è¡¨å¤´éƒ¨
    adjList[u] = newNode;       // ğŸ†™ æ›´æ–°å¤´æŒ‡é’ˆ
}

// =====================================================================================================
// 2ï¸âƒ£ æ‰‹å†™å°æ ¹å † (Min-Heap Implementation)
// =====================================================================================================

EdgeNode *min_heap[MAXM]; // ğŸ“¦ å †æ•°ç»„ (å­˜å‚¨è¾¹çš„æŒ‡é’ˆ)
int heap_size = 0;        // ğŸ“ å½“å‰å †å…ƒç´ ä¸ªæ•°

// ğŸ”„ äº¤æ¢å †ä¸­ä¸¤ä¸ªå…ƒç´ 
void swap(int i, int j)
{
    EdgeNode *temp = min_heap[i];
    min_heap[i] = min_heap[j];
    min_heap[j] = temp;
}

// â¬†ï¸ å…¥å †æ“ä½œ (Swim/ä¸Šæµ®)
void add(EdgeNode *obj)
{
    if (heap_size >= MAXM)
        return;                // ğŸ›¡ï¸ é˜²æ­¢å †æº¢å‡º
    min_heap[heap_size] = obj; // ğŸ“¥ æ”¾å…¥å †å°¾
    int i = heap_size++;       // ğŸ“ è·å–å½“å‰ç´¢å¼•å¹¶è‡ªå¢ size

    // ğŸš€ è‹¥å½“å‰èŠ‚ç‚¹æƒé‡ < çˆ¶èŠ‚ç‚¹,åˆ™ä¸Šæµ®
    while (i > 0 && (min_heap[(i - 1) / 2]->weight) > (min_heap[i]->weight))
    {
        swap(i, (i - 1) / 2); // ğŸ”„ äº¤æ¢ä½ç½®
        i = (i - 1) / 2;      // ğŸ†™ ç´¢å¼•ä¸Šç§»
    }
}

// â¬‡ï¸ å‡ºå †æ“ä½œ (Sink/ä¸‹æ²‰) - å¼¹å‡ºæœ€å°å€¼
EdgeNode *pop()
{

    EdgeNode *min = min_heap[0]; // ğŸ’ å–å‡ºå †é¡¶(æœ€å°å€¼)
    swap(0, --heap_size);        // ğŸ”„ å †å°¾ç§»è‡³å †é¡¶, size-1
    int i = 0;                   // ğŸ“ ä»æ ¹èŠ‚ç‚¹å¼€å§‹
    int l = 2 * i + 1;           // ğŸŒ¿ å·¦å­èŠ‚ç‚¹ç´¢å¼•

    // ğŸ”» å‘ä¸‹è°ƒæ•´,ç»´æŒå°æ ¹å †æ€§è´¨
    while (l < heap_size)
    {
        // ğŸ§ é€‰å‡ºå·¦å³å­èŠ‚ç‚¹ä¸­è¾ƒå°çš„é‚£ä¸ª (best)
        int best = ((l + 1 < heap_size) && (min_heap[l + 1]->weight < min_heap[l]->weight)) ? l + 1 : l;
        // âš–ï¸ æ¯”è¾ƒå½“å‰èŠ‚ç‚¹ä¸å­èŠ‚ç‚¹
        best = (min_heap[best]->weight < min_heap[i]->weight) ? best : i;

        if (best == i) // âœ… è‹¥å·²æ»¡è¶³å †æ€§è´¨,åœæ­¢
            break;
        swap(best, i); // ğŸ”„ å¦åˆ™äº¤æ¢
        i = best;      // ğŸ“ æ›´æ–°å½“å‰ä½ç½®
        l = 2 * i + 1; // ğŸŒ¿ ç§»åŠ¨åˆ°ä¸‹ä¸€å±‚å·¦å­èŠ‚ç‚¹
    }
    return min; // ğŸ“¤ è¿”å›æœ€å°å€¼
}

// â“ åˆ¤æ–­å †æ˜¯å¦ä¸ºç©º
bool isEmpty()
{
    return heap_size == 0;
}

// =====================================================================================================
// 3ï¸âƒ£ ä¸»å‡½æ•°é€»è¾‘ (Main & Prim Algorithm)
// =====================================================================================================

bool set[MAXN]; // ğŸš© è®¿é—®æ ‡è®°æ•°ç»„ (visited)

int main()
{
    if (scanf("%d %d", &n, &m) != 2)
        return 0; // ğŸ“¥ è¯»å– N, M å¹¶æ ¡éªŒ

    build(n);      // ğŸ—ï¸ åˆå§‹åŒ–å›¾
    heap_size = 0; // ğŸ§¹ é‡ç½®å †å¤§å°
    for (int i = 0; i <= n; i++)
        set[i] = false; // ğŸ”„ é‡ç½®è®¿é—®æ ‡è®°

    // ğŸ“ è¯»å– M æ¡è¾¹
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w); // ğŸ“¥ è¯»å–è¾¹ä¿¡æ¯
        addListEdge(u, v, w);          // ğŸ”— åŠ è¾¹ u->v
        addListEdge(v, u, w);          // ğŸ”— åŠ è¾¹ v->u (æ— å‘å›¾)
    }

    // ğŸš€ Prim å¯åŠ¨:å°†èµ·ç‚¹ 1 çš„æ‰€æœ‰è¾¹å…¥å †
    EdgeNode *first = adjList[1];
    while (first)
    {
        add(first); // ğŸ“¥ å…¥å †
        first = first->next;
    }

    int nodeCnt = 1; // ğŸ“Š å·²è¿é€šç‚¹æ•° (åˆå§‹å«èµ·ç‚¹)
    set[1] = true;   // ğŸš© æ ‡è®°èµ·ç‚¹å·²è®¿é—®
    int ans = 0;     // ğŸ’° æœ€å°ç”Ÿæˆæ ‘æ€»æƒå€¼

    // ğŸ”„ ä¸»å¾ªç¯:å †ä¸ç©ºæ—¶æŒç»­è´ªå¿ƒ
    while (!isEmpty())
    {
        EdgeNode *cur = pop();  // ğŸ”¥ è´ªå¿ƒ:å–å‡ºå½“å‰æœ€è¿‘çš„è¾¹
        int next_to = cur->to;  // ğŸ¯ è¾¹çš„ç»ˆç‚¹
        int cost = cur->weight; // âš–ï¸ è¾¹çš„æƒé‡

        // ğŸš¦ æ ¸å¿ƒ:è‹¥ç»ˆç‚¹æœªè®¿é—® (Lazy Prim)
        if (!set[next_to])
        {
            nodeCnt++;           // ğŸ“ˆ è¿é€šç‚¹æ•°+1
            set[next_to] = true; // ğŸš© æ ‡è®°ä¸ºå·²è®¿é—®
            ans += cost;         // â• ç´¯åŠ æƒå€¼

            if (nodeCnt == n) // âš¡ ä¼˜åŒ–:ç‚¹æ‰¾é½äº†æå‰ç»“æŸ
                break;

            // ğŸ”“ æ‹“å±•æ–°èŠ‚ç‚¹çš„æ‰€æœ‰é‚»å±…å…¥å †
            EdgeNode *temp = adjList[next_to];
            while (temp)
            {
                add(temp); // ğŸ“¥ é‚»å±…è¾¹å…¥å †
                temp = temp->next;
            }
        }
    }

    // ğŸ“¤ è¾“å‡ºç»“æœ
    if (nodeCnt == n)
        printf("%d", ans); // ğŸ‰ æˆåŠŸè¿é€š
    else
        printf("orz"); // âŒ å›¾ä¸è¿é€š

    return 0;
}
