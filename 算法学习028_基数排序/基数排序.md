# 算法讲解028【必备】基数排序

**讲师**:左程云 **前置知识**:无

------

## 1. 排序算法的分类

### 基于比较的排序

- **定义**：只需要定义好两个对象之间如何进行比较即可。
- **特点**:
  - 不关心对象具体的数据特征。
  - **非常通用**,适用于各种数据类型。

### 不基于比较的排序

- **定义**:与比较操作无关的排序方式。
- **特点**:
  - 对对象的数据特征有特定要求。
  - **并不通用**，一旦比较对象不再是常规数字，改写算法的代价很大。

------

## 2. 计数排序 (Counting Sort)

- **概述**:原理非常简单。
- **适用条件**：一般要求样本是整数，且数值范围比较窄。
- **局限性**：如果数值范围非常大，计数排序就无法使用了。

------

## 3. 基数排序 (Radix Sort)

### 3.1 核心概念

- 这是一个非常优雅的排序实现。
- **适用范围**:
  - 一般来讲,要求样本是 **10进制的非负整数**。
  - 如果数据不符合要求（如包含负数），需要进行转化。
  - 优秀的实现代码通常支持设置 **任意进制** 来进行排序。

### 3.2 实现关键点

1. **数字提取技巧**：能够从数字中提取出某一位（如个位、十位、百位）的值。
2. **前缀数量分区技巧**:利用前缀和(Prefix Sum)的思想来确定数字在辅助空间中的位置。

### 3.3 复杂度分析

- **时间复杂度**:`O(n)`
- **额外空间复杂度**:`O(m)`
  - 需要辅助空间来发挥类似“桶”的作用，用于不断地装入和弹出数字。

### 3.4注意：

* 一般来讲，计数排序要求，**样本是整数**，且范围比较窄一般来讲，

* 基数排序要求，样本是10进制的**非负整数**

* 如果不是就需要转化，代码里做了转化，并且代码里可以设置任何进制来进行排序

* 一旦比较的对象不再是常规数字，那么改写代价的增加是显而易见的，所以**不基于比较的排序并不通用**

``````c
#include <string.h> // 导入这个头文件,使用memset函数
#define BASE 1000   // 基数,使用1000进制进行排序(可以调整)
#define MAXN 50001  // 数组最大长度

int help[MAXN]; // 辅助数组,用于临时存储排序结果
int cnts[BASE]; // 统计数组,多少进制就准备多长的

// number在BASE进制下有几位
int bits(int number)
{
    int ans = 0;
    while (number > 0)
    {
        ans++;          // 位数加1
        number /= BASE; // 除以基数,去掉最低位
    }
    return ans;
}

// 基数排序的核心代码
// arr中要保证没有负数
// n是arr的长度
// bits是arr中最大值在bits进制下有几位
void radixSort(int arr[], int n, int bits)
{
    // 从最低位到最高位进行排序
    for (int offset = 1; bits > 0; offset *= BASE, bits--)
    {
        memset(cnts, 0, sizeof(cnts)); // 最开始吧词频都初始化为0
        int i = 0;
        for (i = 0; i < n; i++) // 第一步:数字的词频统计
        {
            cnts[(arr[i] / offset) % BASE]++; // 数字提取某一位的技巧
        }
        for (i = 1; i < BASE; i++) // 第二步:处理前缀次数累加的形式
        {
            cnts[i] = cnts[i] + cnts[i - 1]; // 累计前缀和
        }
        for (i = n - 1; i >= 0; i--) // 第三步:开始分区,从右往左遍历(保证排序的稳定性)
        {
            // (arr[i] / offset) % BASE]: 这一位的数字
            help[--cnts[(arr[i] / offset) % BASE]] = arr[i]; // 从后往前放置元素
        }
        for (i = 0; i < n; i++) // 第四步:将排序结果从辅助数组复制回原数组
        {
            arr[i] = help[i]; // 复制当前轮的排序结果
        }
    }
}
``````

