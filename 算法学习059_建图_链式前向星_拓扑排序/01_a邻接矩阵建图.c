/**
 * @file GraphMatrix.c
 * @brief ğŸš€ åŸºäºé‚»æ¥çŸ©é˜µçš„å¸¦æƒå›¾è¡¨ç¤ºæ³•
 * -------------------------------------------------------------------------
 * ğŸ“ ã€é¢˜ç›®æè¿°ã€‘
 * -------------------------------------------------------------------------
 * åœ¨å›¾è®ºä¸­,é‚»æ¥çŸ©é˜µ(Adjacency Matrix)æ˜¯è¡¨ç¤ºé¡¶ç‚¹ä¹‹é—´ç›¸é‚»å…³ç³»çš„çŸ©é˜µ.
 * è¯·æŒ‰ç…§ä»¥ä¸‹è¦æ±‚å®Œæˆä»£ç ç»ƒä¹ :
 * * 1. ğŸ“ èŠ‚ç‚¹è§„èŒƒ:å‡è®¾å›¾æœ€å¤šæœ‰ 10 ä¸ªèŠ‚ç‚¹,ç¼–å·ä» 1 å¼€å§‹(å¦‚:èŠ‚ç‚¹1, èŠ‚ç‚¹2...).
 * 2. ğŸ“Š æ•°æ®ç»“æ„:ä½¿ç”¨ä¸€ä¸ªåä¸º `adjMatrix` çš„äºŒç»´æ•°ç»„è¡¨ç¤ºå›¾.
 * 3. âš™ï¸ åŠŸèƒ½å®ç°:
 * - åˆå§‹åŒ–:å°†çŸ©é˜µæ‰€æœ‰æƒå€¼æ¸…ç©ºä¸º 0.
 * - æœ‰å‘å›¾æ„å»º:ä¼ å…¥è¾¹é›† `[[èµ·ç‚¹, ç»ˆç‚¹, æƒé‡], ...]`,åœ¨çŸ©é˜µä¸­å¡«å…¥å¯¹åº”æƒé‡.
 * - æ— å‘å›¾æ„å»º:åŒä¸Š,ä½†éœ€æ»¡è¶³çŸ©é˜µçš„å¯¹ç§°æ€§.
 * - éå†æ‰“å°:è¾“å‡º n x n çš„å®Œæ•´çŸ©é˜µè§†å›¾.
 * * 4. ğŸ§® æ•°å­¦è¡¨ç¤º:
 * å¯¹äºå¸¦æƒå›¾,é‚»æ¥çŸ©é˜µ A çš„å®šä¹‰ä¸º:
 * A[i][j] = w (å¦‚æœå­˜åœ¨è¾¹ i->j ä¸”æƒé‡ä¸º w);å¦åˆ™ A[i][j] = 0.
 * * -------------------------------------------------------------------------
 * ğŸ§ª ã€æµ‹è¯•ç”¨ä¾‹ä¸é¢„æœŸç»“æœã€‘
 * -------------------------------------------------------------------------
 * Case 1: æœ‰å‘å¸¦æƒå›¾ (n=4)
 * è¾“å…¥è¾¹é›†: {{1,3,6}, {4,3,4}, {2,4,2}, {1,2,7}, {2,3,5}, {3,1,1}}
 * é¢„æœŸçŸ©é˜µè¾“å‡º:
 * 0 7 6 0
 * 0 0 5 2
 * 1 0 0 0
 * 0 0 4 0
 * * Case 2: æ— å‘å¸¦æƒå›¾ (n=5)
 * è¾“å…¥è¾¹é›†: {{3,5,4}, {4,1,1}, {3,4,2}, {5,2,4}, {2,3,7}, {1,5,5}, {4,2,6}}
 * é¢„æœŸçŸ©é˜µè¾“å‡º:
 * 0 0 0 1 5
 * 0 0 7 6 4
 * 0 7 0 2 4
 * 1 6 2 0 0
 * 5 4 4 0 0
 * -------------------------------------------------------------------------
 */

#include <stdio.h>
#include <string.h> // ä½¿ç”¨ memset å°†çŸ©é˜µæ‰€æœ‰æƒå€¼é‡ç½®ä¸º 0

#define MAX 11 // MAX è®¾ä¸º 11 ä»¥é€‚é… 1~10 å·èŠ‚ç‚¹çš„ç´¢å¼•å­˜å‚¨

int adjMatrix[MAX][MAX]; // ğŸ“Š adjMatrix: é‚»æ¥çŸ©é˜µå­˜å‚¨ç©ºé—´ (0å·ä¸‹æ ‡å¼ƒç”¨)

// ğŸ§¹ åˆå§‹åŒ–/æ¸…ç©ºå»ºå›¾æ•°æ®,
void build()
{
    memset(adjMatrix, 0, sizeof(adjMatrix)); // æ¸…ç©ºé‚»æ¥çŸ©é˜µ
}

/**
 * â¡ï¸ å»ºç«‹æœ‰å‘å¸¦æƒå›¾
 * @param edges è¾¹æ•°æ®æ•°ç»„ [u, v, w] (èµ·ç‚¹, ç»ˆç‚¹, æƒé‡)
 * @param edgeSize è¾¹çš„æ€»æ•°é‡
 */
void directGraph(int edges[][3], int edgeSize)
{
    int n = edgeSize; // ä¸€å…±æœ‰næ¡è¾¹
    for (int i = 0; i < n; i++)
    {
        int u = edges[i][0]; // èµ·ç‚¹
        int v = edges[i][1]; // ç»ˆç‚¹
        int w = edges[i][2]; // æƒé‡

        adjMatrix[u][v] = w; // é‚»æ¥çŸ©é˜µ:è®°å½• u åˆ° v çš„å•å‘è¾¹
    }
}

/**
 * â†”ï¸ å»ºç«‹æ— å‘å¸¦æƒå›¾
 * @param edges è¾¹æ•°æ®æ•°ç»„ [u, v, w]
 * @param edgeSize è¾¹çš„æ€»æ•°é‡
 */
void undirectGraph(int edges[][3], int edgeSize)
{
    int n = edgeSize; // ä¸€å…±æœ‰næ¡è¾¹
    for (int i = 0; i < n; i++)
    {
        int u = edges[i][0]; // èµ·ç‚¹
        int v = edges[i][1]; // ç»ˆç‚¹
        int w = edges[i][2]; // æƒé‡

        adjMatrix[u][v] = w; // è®°å½• u åˆ° v
        adjMatrix[v][u] = w; // è®°å½• v åˆ° u (æ— å‘å›¾åŒå‘å¯¹ç§°)
    }
}

/**
 * ğŸ” çŸ©é˜µéå†æ‰“å°
 * @param n å®é™…ä½¿ç”¨çš„èŠ‚ç‚¹æ•°é‡
 */
void traversal(int n)
{
    printf("Traversing an adjacency matrix :\n");
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            printf("%d ", adjMatrix[i][j]);
        }
        printf("\n");
    }
}

/**
 * ğŸš€ ä¸»ç¨‹åºæµ‹è¯•å…¥å£
 */
int main()
{
    // ğŸ’¡ ä¾‹å­ 1: æœ‰å‘å¸¦æƒå›¾ (æµ‹è¯•èŠ‚ç‚¹ 1,2,3,4)
    int n1 = 4;
    int edges1[][3] = {{1, 3, 6}, {4, 3, 4}, {2, 4, 2}, {1, 2, 7}, {2, 3, 5}, {3, 1, 1}};
    int size1 = sizeof(edges1) / sizeof(edges1[0]);

    build();
    directGraph(edges1, size1);
    traversal(n1);

    printf("==============================\n");

    // ğŸ’¡ ä¾‹å­ 2: æ— å‘å¸¦æƒå›¾ (æµ‹è¯•èŠ‚ç‚¹ 1,2,3,4,5)
    int n2 = 5;
    int edges2[][3] = {{3, 5, 4}, {4, 1, 1}, {3, 4, 2}, {5, 2, 4}, {2, 3, 7}, {1, 5, 5}, {4, 2, 6}};
    int size2 = sizeof(edges2) / sizeof(edges2[0]);

    build();
    undirectGraph(edges2, size2);
    traversal(n2);

    return 0;
}
