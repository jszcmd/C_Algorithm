#include <stdlib.h>
#include <time.h>

// 力扣测试连接:https://leetcode.cn/problems/kth-largest-element-in-an-array/
// 用C语言实现真的很快,这段代码的内容很短的,只不过是用AI美化了一下注释

/* ? 分区边界全局变量 */
static int first = 0; // ? 等于区的起始位置
static int last = 0;  // ? 等于区的结束位置

/* ============================================================================
   ? 随机数生成器
   ============================================================================ */

/**
 * ? 生成指定范围内的随机整数
 *
 * @param l 范围下限（包含）
 * @param r 范围上限（包含）
 * @return [l, r]范围内的随机整数
 *
 * ? 特点：线程不安全，但效率高
 */
int randint(int l, int r)
{
    static int initialized = 0; // ? 种子初始化标志

    if (!initialized)
    {
        srand(time(NULL)); // ? 用当前时间初始化随机种子
        initialized = 1;   // ? 标记已初始化
    }

    return rand() % (r - l + 1) + l; // ? 生成随机数
}

/* ============================================================================
   ? 核心工具函数
   ============================================================================ */

/**
 * ? 交换数组中的两个元素
 *
 * @param arr 目标数组
 * @param a   第一个元素索引
 * @param b   第二个元素索引
 *
 * ? 经典的三变量交换法
 */
void swap(int arr[], int a, int b)
{
    int temp = arr[a]; // ? 临时存储
    arr[a] = arr[b];   // ? 交换位置
    arr[b] = temp;     // ? 完成交换
}

/* ============================================================================
   ???? 荷兰国旗分区算法
   ============================================================================ */

/**
 * ? 三路快速排序分区算法
 *
 * 将数组 arr[l..r] 划分为三个区域：
 *   ? [l, first-1] : 小于基准值的元素
 *   ? [first, last] : 等于基准值的元素
 *   ? [last+1, r]   : 大于基准值的元素
 *
 * @param arr 待分区数组
 * @param l   分区左边界
 * @param r   分区右边界
 * @param x   基准值
 *
 * ? 算法复杂度：O(n)
 */
void partition(int arr[], int l, int r, int x)
{
    first = l; // ? 初始化小于区边界
    last = r;  // ? 初始化大于区边界
    int i = l; // ? 当前扫描指针

    /* ? 扫描整个区间 */
    while (i <= last)
    {
        if (arr[i] == x)
        {
            i++; // ? 等于基准值，留在中间
        }
        else if (arr[i] < x)
        {
            swap(arr, first++, i++); // ? 小于基准值，交换到左边
        }
        else
        {
            swap(arr, last--, i); // ? 大于基准值，交换到右边
        }
    }
}

/* ============================================================================
   ? 快速选择算法
   ============================================================================ */

/**
 * ? 快速选择：在未排序数组中查找第i小的元素
 *
 * ? 算法思想：
 *   - 随机选择基准值进行分区
 *   - 只在包含目标的子区间中递归搜索
 *   - 平均复杂度：O(n)，最坏：O(n?)
 *
 * @param arr  输入数组
 * @param len  数组长度
 * @param i    目标位置（0-indexed）
 * @return     排序后会在位置i的元素值
 *
 * ? 比完全排序更高效的选择算法
 */
int randomizedSelect(int arr[], int len, int i)
{
    int ans = 0;     // ? 存储最终结果
    int l = 0;       // ? 搜索区间左边界
    int r = len - 1; // ? 搜索区间右边界

    /* ? 迭代搜索目标元素 */
    while (l <= r)
    {
        /* ? 随机选择基准值并分区 */
        int pivot_index = randint(l, r);
        partition(arr, l, r, arr[pivot_index]);

        /* ? 根据分区结果调整搜索区间 */
        if (i < first)
        {
            r = first - 1; // ? 目标在左分区
        }
        else if (i > last)
        {
            l = last + 1; // ? 目标在右分区
        }
        else
        {
            ans = arr[i]; // ? 找到目标！
            break;
        }
    }

    return ans;
}

/* ============================================================================
   ? 主接口函数
   ============================================================================ */

/**
 * ? 查找数组中第K大的元素
 *
 * ? 核心转换：
 *   - 第1大 = 最大值 = 排序后第 (n-1) 个元素
 *   - 第k大 = 排序后第 (n-k) 个元素
 *
 * @param nums     输入数组
 * @param numsSize 数组大小
 * @param k        第k大（1-indexed）
 * @return         第k大的元素值
 *
 * ? 应用场景：TopK问题、中位数查找等
 */
int findKthLargest(int *nums, int numsSize, int k)
{
    return randomizedSelect(nums, numsSize, numsSize - k);
}
