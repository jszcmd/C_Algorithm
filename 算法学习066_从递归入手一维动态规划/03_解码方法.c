// 解码方法
// 一条包含字母 A-Z 的消息通过以下映射进行了 编码 :
// 'A' -> "1"
// 'B' -> "2"
// ...
// 'Z' -> "26"
// 要 解码 已编码的消息,所有数字必须基于上述映射的方法,反向映射回字母(可能有多种方法)
// 例如,"11106" 可以映射为："AAJF"、"KJF"
// 注意,消息不能分组为(1 11 06),因为 "06" 不能映射为 "F"
// 这是由于 "6" 和 "06" 在映射中并不等价
// 给你一个只含数字的 非空 字符串 s ,请计算并返回 解码 方法的 总数
// 题目数据保证答案肯定是一个 32位 的整数
// 测试链接 : https://leetcode.cn/problems/decode-ways/

// ========================================================================================
// 方法1: 暴力递归.

#include <string.h>
// s :数字字符串
// s[i...]从i位置开始,有多少种有效的转化方案.
int f1(char *s, int len, int i)
{
    if (i == len) // 越界的时候有一种转换的方案,之前对应的具体的决策到底了.
    {
        return 1; // 之前形成的情况是一种有效的方案.
    }
    else // 还有字符,没有越界.
    {
        int ans = 0;
        if (s[i] == '0') // i位置是'0'字符
        {
            ans = 0; // 说明之前转的不对,这种情况不行.
        }
        else // s[i] != '0'
        {
            // i位置单独 转成一个字符
            ans += f1(s, len, i + 1); // 只要不是'0',那么从i+1往下转换的方法数.
            // (i i+1)位置的字符一起转
            // (i + 1 < len) 有i+1位置
            // (s[i] - '0') * 10 + (s[i + 1] - '0') <= 26) 组成的2个数 <=26
            if ((i + 1 < len) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26))
            {
                ans += f1(s, len, i + 2);
            }
        }
        return ans;
    }
}

int numDecodings(char *s)
{
    int len = strlen(s);
    return f1(s, len, 0);
}

// ========================================================================================
// 方法2: 暴力尝试改记忆化搜索  ---> 挂缓存表
// 时间复杂度: O(n)   空间复杂度: O(n)

int f2(char *s, int len, int i, int *dp)
{
    if (i == len) // 越界的时候有一种转换的方案,之前对应的具体的决策到底了.
    {
        return 1; // 之前形成的情况是一种有效的方案.
    }
    else // 还有字符,没有越界.
    {
        if (dp[i] != -1) // 如果之前算过了
        {
            return dp[i]; // 直接返回
        }
        else // dp[i] == -1;没有展开过,现在展开
        {
            int ans = 0;
            if (s[i] == '0') // i位置是'0'字符
            {
                ans = 0; // 说明之前转的不对,这种情况不行.
            }
            else // s[i] != '0'
            {
                // i位置单独 转成一个字符
                ans += f2(s, len, i + 1, dp); // 只要不是'0',那么从i+1往下转换的方法数.
                // (i i+1)位置的字符一起转
                // (i + 1 < len) 有i+1位置
                // (s[i] - '0') * 10 + (s[i + 1] - '0') <= 26) 组成的2个数 <=26
                if ((i + 1 < len) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26))
                {
                    ans += f2(s, len, i + 2, dp);
                }
            }
            dp[i] = ans; // 展开的结果在返回之前挂到缓存表里面.
            return ans;
        }
    }
}

int numDecodings2(char *s)
{
    int len = strlen(s);
    int dp[len];                // 准备一个缓存表
    memset(dp, -1, sizeof(dp)); // 一开始都初始化为-1,表示没有计算过;
    return f2(s, len, 0, dp);
}

// ========================================================================================
// 方法3: 严格位置依赖的动态规划 ---> i位置依赖 i+1位置 和 i+2位置.
// 时间复杂度: O(n)   空间复杂度: O(n)
// 从n位置的格子开始填写 ----> 填写到0位置   ---->  返回

int numDecodings3(char *s)
{
    int n = strlen(s);
    int dp[n + 1]; // 准备一个缓存表
    dp[n] = 1;
    for (int i = n - 1; i >= 0; i--)
    {
        if (s[i] == '0')
        {
            dp[i] = 0;
        }
        else // dp[i] = dp[i+1] + dp[i+2] (一般情况)
        {
            dp[i] = dp[i + 1];
            if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26))
            {
                dp[i] += dp[i + 2];
            }
        }
    }
    return dp[0];
}

// 测试链接 : https://leetcode.cn/problems/decode-ways/
// ========================================================================================
// 方法4: 严格位置依赖的动态规划 + 空间压缩
// 时间复杂度: O(n)   空间复杂度: O(1)

int numDecodings4(char *s)
{
    int n = strlen(s);
    // dp[n] = 1
    int next = 1; // next位置就等效于 dp[i+1]
    // dp[n+1] = 0 (最开始不存在)
    int next_next = 0;                    // next_next位置就等效于 dp[i+2]
    for (int i = n - 1, cur; i >= 0; i--) // cur代替dp[i]
    {
        if (s[i] == '0')
        {
            cur = 0;
        }
        else
        {
            cur = next;
            if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26))
            {
                cur += next_next;
            }
        }
        next_next = next; // next_next往前动一步
        next = cur;       // next往前动一步.
    }
    return next;
}
