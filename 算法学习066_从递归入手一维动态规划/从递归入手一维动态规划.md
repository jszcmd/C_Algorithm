# 算法讲解066【必备】从递归入手一维动态规划

**主讲人**：左程云

------

## 1. 前置知识与课程定位

### 前置要求

- **必须熟悉递归**。如果不熟悉，请参考以下课程：
  - 讲解017、020-023
  - 讲解036-040
- **关于取模**：
  - 讲解041-同余原理

### 本节课核心目标

- 从基本递归入手，了解一维动态规划。
- **注意**：现阶段暂时不深究“重叠子问题”、“最优子结构”、“无后效性”等理论概念，这些将在动态规划专题结束时的“大总结”中进行。

------

## 2. 动态规划的核心思想

**动态规划 (Dynamic Programming)**：用空间代替重复计算，是包含一整套原理和技巧的总和。

### 递归 vs 动态规划

- **核心区别**：有些递归在展开计算时，总是**重复调用同一个子问题的解**。这种重复调用的递归变成动态规划很有收益。
- **无需改写的情况**：如果每次展开都是不同的解，或者重复调用很少，则没有必要改写为动态规划。
- **对应关系**：任何动态规划问题一定对应着一个有重复调用行为的递归。

### 学习建议

1. **从递归入手**：尝试策略（递归）就是转移方程。推荐从尝试入手，因为代码好写，且试错成本低。
2. **避免邯郸学步**：如果不熟悉从递归到动态规划的转化过程，直接硬去理解状态转移方程，往往会步履维艰。
3. **循序渐进**：
   - **题目1-4**：从递归入手，逐渐改出动态规划。
   - **题目5-8**：当熟悉转化过程后，纯粹用动态规划视角分析和优化。

------

## 3. 动态规划的标准流程

1. **想出设计优良的递归尝试**（方法、经验、固定套路很多）。
2. **记忆化搜索**（从顶到底的动态规划）：如果状态枚举代价低，往往到这一步即可。
3. **严格位置依赖的动态规划**（从底到顶的动态规划）：为进一步优化枚举做准备。
4. **进一步优化空间**（空间压缩）：一维、二维、多维均存在此优化。
5. **进一步优化枚举**（优化时间）：后续课程会涉及。

------

## 4. 题目练习

### 题目 1：斐波那契数

- **描述**：$F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)$。给定 $n$ 计算 $F(n)$。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/fibonacci-number/)
- **备注**：本节课讲解 $O(n)$ 方法。最优解是矩阵快速幂 $O(\log n)$，后续课程会讲。
- 代码：

``````c
// 测试链接 : https://leetcode.cn/problems/fibonacci-number/
// ==================================================================================
// 方法4:从底到顶的动态规划,严格位置依赖的动态规划.
// 时间复杂度也是: 0(n)  -----> 进行空间的优化: 空间复杂度: O(1)

int fib4(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    int last_last = 0; // 一开始,前一个的前一个也就是:F(0) = 0
    int last = 1;      // 最开始前一个是 1
    for (int i = 2, cur; i <= n; i++)
    {
        cur = last + last_last;
        last_last = last;
        last = cur;
    }
    return last;
}

// *** 任何动态规划问题:都一定有重复调用行为的递归.
``````



### 题目 2：最低票价

- **描述**：给定旅行日子数组 `days`。火车票有 1天、7天、30天三种通行证，价格分别为 `costs[0]`, `costs[1]`, `costs[2]`。求完成所有旅行日子的最低消费。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/minimum-cost-for-tickets/)
- 代码：

``````c
// 测试链接 : https://leetcode.cn/problems/minimum-cost-for-tickets/
// =================================================================================================
// 方法3：实现一个从低到顶的，严格位置依赖的动态规划...   ----------> 从后往前计算.
// 时间复杂度: O(N)

int dp[366]; // 算上越界位置,最多366

int mincostTickets(int *days, int daysSize, int *costs, int costsSize)
{
    int n = daysSize;
    for (int i = 0; i <= n; i++)
        dp[i] = INT_MAX;

    dp[n] = 0; // 越界位置也要使用,花0元
    for (int i = n - 1; i >= 0; i--)
    {
        for (int k = 0, j = i; k < 3; k++)
        {
            while (j < daysSize && (days[i] + durations[k] > days[j]))
            {
                j++;
            }
            dp[i] = MIN(dp[i], costs[k] + dp[j]);
        }
    }

    return dp[0];
}
``````

### 题目 3：解码方法 (I)

- **描述**：映射关系 'A'->"1" ... 'Z'->"26"。给定数字字符串，求有多少种解码方法。
- **注意**："06" 不能映射为 'F'。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/decode-ways/)

``````c
// 测试链接 : https://leetcode.cn/problems/decode-ways/
// ========================================================================================
// 方法4: 严格位置依赖的动态规划 + 空间压缩
// 时间复杂度: O(n)   空间复杂度: O(1)

int numDecodings4(char *s)
{
    int n = strlen(s);
    // dp[n] = 1
    int next = 1; // next位置就等效于 dp[i+1]
    // dp[n+1] = 0 (最开始不存在)
    int next_next = 0;                    // next_next位置就等效于 dp[i+2]
    for (int i = n - 1, cur; i >= 0; i--) // cur代替dp[i]
    {
        if (s[i] == '0')
        {
            cur = 0;
        }
        else
        {
            cur = next;
            if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26))
            {
                cur += next_next;
            }
        }
        next_next = next; // next_next往前动一步
        next = cur;       // next往前动一步.
    }
    return next;
}
``````

### 题目 4：解码方法 (II)

- **描述**：在题目3的基础上增加了字符 `*`。`*` 可以表示 '1' 到 '9' 的任一数字。
  - 例如 "1*" 可以表示 "11" 到 "19"。
- **要求**：结果对 $10^9 + 7$ 取模。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/decode-ways-ii/)
- 代码：

``````c
// 测试链接 : https://leetcode.cn/problems/decode-ways-ii/
// ========================================================================================
// 方法4: 严格位置依赖的动态规划 + 空间压缩

int numDecodings4(char *s)
{
    int n = strlen(s);
    long cur = 0, next = 1, next_next = 0;
    for (int i = n - 1, cur; i >= 0; i--)
    {
        if (s[i] == '0')
        {
            cur = 0;
        }
        else // s[i] != '0'
        {
            long ans = 0;

            // i位置想单独转换 ---> i位置要么是* 要么是1~9中的一个数
            ans += next * ((s[i] == '*') ? 9 : 1);

            // i想拉着i+1一起转换
            if (i + 1 < n) // 保证有i+1位置
            {
                if (s[i] != '*') // s[i]不是'*',是具体的数字
                {
                    if (s[i + 1] != '*') // s[i+1]位置也是具体数字
                    {
                        if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26)) // 组成的2位数在10到26之间.
                        {
                            ans += next_next;
                        }
                        else // 组成的2位数大于26
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                    else // i位置是一个具体的数字; i+1 位置是一个'*'
                    {
                        if (s[i] == '1') // 是 11到19的任意一个数
                        {
                            ans += next_next * 9; // 9种可能
                        }
                        else if (s[i] == '2') // 是21到26的任意一个数
                        {
                            ans += next_next * 6; // 6种可能
                        }
                        else // 是31以及以后的数字
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                }
                else // i位置的字符是 '*'
                {
                    if (s[i + 1] != '*') // i位置是* i+1位置是一个确定的数字
                    {
                        if (s[i + 1] <= '6') // i+1位置的数在6以内
                        {
                            ans += next_next * 2; // (1,确定的数字)或者(2,确定的数字) 2种可能
                        }
                        else // i+1位置的数 可能是 7 8 9
                        {
                            ans += next_next; // (1,确定的数字)
                        }
                    }
                    else // i位置是* i+1位置也是*
                    {
                        ans += next_next * 15; // 11到19 | 21到26 ===> 15种情况
                    }
                }
            }
            ans = ans % mod; // 取模之后
            cur = ans;       // 挂到缓存表
        }
        next_next = next;
        next = cur;
        cur = 0;
    }
    return (int)next;
}

``````

### 题目 5：丑数 II

- **描述**：丑数是只包含质因数 2、3 或 5 的正整数。求第 $n$ 个丑数。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/ugly-number-ii/)
- 代码：

``````c
// 题目5
// 丑数 II
// 丑数 就是只包含质因数 2、3 或 5 的正整数
// 默认第1个丑数是1，前几项丑数为:
// 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20,
// 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60,
// 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125..
// 给你一个整数n ,请你找出并返回第n个丑数
// 比如,n = 37,返回125
// 测试链接 : https://leetcode.cn/problems/ugly-number-ii/

int min(int x, int y, int z)
{
    int min = (x < y) ? x : y;
    min = (min < z) ? min : z;
    return min;
}

int nthUglyNumber(int n)
{
    // 没有第0个丑数,下标0位置弃而不用
    int dp[n + 1]; // dp表要填写到第n项.dp[n]
    dp[1] = 1;     // 第一个丑数是1
    // i 当前在计算第i项丑数
    // i2的意思是 乘2 的指针停在哪一个下标
    // i3的意思是 乘3 的指针停在哪一个下标
    // i5的意思是 乘5 的指针停在哪一个下标
    for (int i = 2, i2 = 1, i3 = 1, i5 = 1, a, b, c, cur; i <= n; i++)
    {
        a = dp[i2] * 2;
        b = dp[i3] * 3;
        c = dp[i5] * 5;
        cur = min(a, b, c);
        if (cur == a)
            i2++;
        if (cur == b)
            i3++;
        if (cur == c)
            i5++;
        dp[i] = cur; // 把当前的丑数放在dp[i]的位置.
    }
    return dp[n];
}

``````

### 题目 6：最长有效括号

- **描述**：给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/longest-valid-parentheses/)
- 代码：

``````c
// 最长有效括号
// 给你一个只包含 '(' 和 ')' 的字符串
// 找出最长有效（格式正确且连续）括号子串的长度.
// 测试链接 : https://leetcode.cn/problems/longest-valid-parentheses/

// 如果s[i]是'(', dp[i]=0;
// 如果s[i]是')', 根据dp[i-1]的长度往前跳到匹配的p位置,p = i-dp[i-1]-1
//                a:  s[p]是')', dp[i]=0
//                b:  s[p]是'(', dp[i]=dp[i-1]+2+dp[p-1],如果dp[p-1]不存在,则为0
//                c:  p<0,没有值了,那么dp[i]=0

#include <string.h>

int longestValidParentheses(char *s)
{
    int n = strlen(s);
    if (n == 0) // 有空字符串的情况
    {
        return 0; // 直接返回0
    }
    else // 非空字符串.
    {
        // dp[i]的含义:字串必须以i位置的字符结尾的情况下,往左最多推多远,能整体有效
        int dp[n];
        dp[0] = 0; // dp[0]的字符一定是0
        int ans = 0;
        for (int i = 1, p; i < n; i++)
        {
            if (s[i] == '(') // 如果s[i]是'(', dp[i]=0;
            {
                dp[i] = 0;
            }
            else // 如果s[i]是')', 根据dp[i-1]的长度往前跳到匹配的p位置,p = i-dp[i-1]-1
            {
                p = i - dp[i - 1] - 1;
                if (p < 0) // c:  p<0,没有值了,那么dp[i]=0
                {
                    dp[i] = 0;
                }
                else // p没有越界.
                {
                    if (s[p] == ')') // a:  s[p]是')', dp[i]=0
                    {
                        dp[i] = 0;
                    }
                    else // b:  s[p]是'(', dp[i]=dp[i-1]+2+dp[p-1],如果dp[p-1]不存在,则为0
                    {
                        dp[i] = dp[i - 1] + 2 + (p - 1 > 0 ? dp[p - 1] : 0);
                    }
                }
            }
        }
        for (int i = 0; i < n; i++)
        {
            ans = (ans > dp[i]) ? ans : dp[i];
        }
        return ans;
    }
}
``````

### 题目 7：环绕字符串中唯一的子字符串

- **描述**：`base` 为 "a...zA...z" 无限环绕字符串。给定字符串 `s`，统计 `s` 中有多少**不同、非空子串**也在 `base` 中出现。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)
- 代码：

``````c
// 环绕字符串中唯一的子字符串
// 定义字符串 base 为一个 "abcdefghijklmnopqrstuvwxyz" 无限环绕的字符串
// 所以 base 看起来是这样的：
// "..zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.."
// 给你一个字符串 s ，请你统计并返回 s 中有多少 不同非空子串 也在 base 中出现
// 测试链接 : https://leetcode.cn/problems/unique-substrings-in-wraparound-string/

#include <string.h>

int findSubstringInWraproundString(char *s)
{
    int n = strlen(s);
    int numStr[n];
    // 'a' --> 0 ; 'b' --> '1' ; ... ; 'z' --> 25
    for (int i = 0; i < n; i++)
    {
        numStr[i] = s[i] - 'a'; // 把字符数组,对应成数字数组.
    }
    // dp[0] 表示在s中必须以'a'结尾的字串,最大延伸的长度是多少,延伸一定要根据base串的规则.
    int dp[26];
    memset(dp, 0, sizeof(dp)); // 初始化为全0.
    // s串中第1个字符,s[0],dp[s[0]-'a'] = 0;
    dp[numStr[0]] = 1;
    for (int i = 1, cur, pre, len = 1; i < n; i++)
    {
        cur = numStr[i];     // 当前字符
        pre = numStr[i - 1]; // 上一个字符.
        // (pre == 25)前一个字符是'z' && (cur == 0)当前字符是'a'
        // 或者前一个字符的ASCII码比后一个字符的ASCII码少一个,也是可以延伸的
        if ((pre == 25) && (cur == 0) || (pre + 1 == cur))
        {
            len++; // 能够延伸,len长度加1
        }
        else // 不能延伸
        {
            len = 1; // 就是只有当前字符,len=1
        }
        dp[cur] = (dp[cur] > len) ? dp[cur] : len; // 更新dp表中当前字符的能够延伸的长度
    }
    int ans = 0;
    for (int i = 0; i < 26; i++)
    {
        ans += dp[i]; // 长度累加.
    }
    return ans;
}
``````

### 题目 8：不同的子序列 II

- **描述**：给定字符串 `s`，计算 `s` 的**不同非空子序列**的个数。
- **要求**：结果对 $10^9 + 7$ 取模。
- **链接**：[LeetCode 传送门](https://leetcode.cn/problems/distinct-subsequences-ii/)
- 代码：

``````c
// 不同的子序列 II
// 给定一个字符串 s，计算 s 的 不同非空子序列 的个数
// 因为结果可能很大，答案对 1000000007 取模
// 字符串的 子序列 是经由原字符串删除一些（也可能不删除）
// 字符但不改变剩余字符相对位置的一个新字符串
// 例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是
// 测试链接 : https://leetcode.cn/problems/distinct-subsequences-ii/

// s = "abc"
// 输出: 7
// 解释: 7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc".

// 输入: s = "aba"
// 输出: 6
// 解释: 6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba".

// 输入: s = "aaa"
// 输出: 3
// 解释: 3 个不同的子序列分别是 "a", "aa" 以及 "aaa".

// 纯新增的数量: all - 当前字符的上次记录
// 当前字符记录 += 纯新增的数量
// all += 纯新增的数量

#include <string.h>
int distinctSubseqII(char *s)
{
    int n = strlen(s); // 字符串s的长度
    if (n == 0)        // 空字符串,就不用考虑了
    {
        return 0; // 直接返回0
    }
    else // 时间复杂度O(n),n是字符串s的长度
    {
        int mod = 1000000007; // 取模mod
        int cnt[26];
        memset(cnt, 0, sizeof(cnt)); // 初始化为全0
        int all = 1, newAdd = 0;
        for (int i = 0; i < n; i++)
        {
            char x = s[i];                                // 当前遍历到的字符
            newAdd = (all - cnt[x - 'a'] + mod) % mod;    // 纯新增的数量: all - 当前字符的上次记录
            cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod; // 当前字符记录 += 纯新增的数量
            all = (all + newAdd) % mod;                   // all += 纯新增的数量
        }
        return (all - 1 + mod) % mod;
    }
}

``````

