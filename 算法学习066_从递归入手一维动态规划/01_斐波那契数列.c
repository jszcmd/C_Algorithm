// 斐波那契数
// 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列
// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
// 也就是：F(0) = 0,F(1) = 1
// F(n) = F(n - 1) + F(n - 2),其中 n > 1
// 给定 n ,请计算 F(n)
// 测试链接 : https://leetcode.cn/problems/fibonacci-number/
// 注意:最优解来自矩阵快速幂,时间复杂度可以做到O(log n)

#include <stdio.h>
#include <string.h>

// ==================================================================================
// 经典的暴力递归

// 直接暴力递归:时间复杂度:O(2^n)
int fib(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    return fib(n - 1) + fib(n - 2);
}

// ==================================================================================
// 方法2: 从顶到底的动态规划,记忆化搜索,某一个参数的返回值已经算出来了,返回值记录.

// 方法2: 做缓存   ---> 时间复杂度: O(n)

// 返回F(i)的值,并在更新缓存表.
int f2(int i, int *dp)
{
    if (i == 0) // 递归结束条件
        return 0;
    if (i == 1) // 递归结束条件
        return 1;

    if (dp[i] != -1) // 缓存表里面有F(i)的值
    {
        return dp[i]; // 直接返回这个不是-1的值
    }
    else // 缓存表里面没有,也就是 dp[i] == -1
    {
        int ans = f2(i - 1, dp) + f2(i - 2, dp); // 辛辛苦苦递归计算
        dp[i] = ans;                             // 做缓存记录
        return ans;                              // 返回辛苦递归计算出来的值
    }
}

// 时间复杂度: O(n)
int fib2(int n)
{
    int dp[n + 1];              // 缓存表
    memset(dp, -1, sizeof(dp)); // 一开始都初始化为-1
    return f2(n, dp);
}

// ==================================================================================
// 方法3:从底到顶的动态规划,严格位置依赖的动态规划.
// 时间复杂度也是: 0(n)

int fib3(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    int dp[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

// 测试链接 : https://leetcode.cn/problems/fibonacci-number/
// ==================================================================================
// 方法4:从底到顶的动态规划,严格位置依赖的动态规划.
// 时间复杂度也是: 0(n)  -----> 进行空间的优化: 空间复杂度: O(1)

int fib4(int n)
{
    if (n == 0)
        return 0;
    if (n == 1)
        return 1;
    int last_last = 0; // 一开始,前一个的前一个也就是:F(0) = 0
    int last = 1;      // 最开始前一个是 1
    for (int i = 2, cur; i <= n; i++)
    {
        cur = last + last_last;
        last_last = last;
        last = cur;
    }
    return last;
}

// *** 任何动态规划问题:都一定有重复调用行为的递归.
