// 解码方法 II
// 一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ：
// 'A' -> "1"
// 'B' -> "2"
// ...
// 'Z' -> "26"
// 要 解码 一条已编码的消息，所有的数字都必须分组
// 然后按原来的编码方案反向映射回字母（可能存在多种方式）
// 例如，"11106" 可以映射为："AAJF"、"KJF"
// 注意，像 (1 11 06) 这样的分组是无效的，"06"不可以映射为'F'
// 除了上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符
// 可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）
// 例如，"1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19"
// 对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息
// 给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目
// 由于答案数目可能非常大，答案对 1000000007 取模
// 测试链接 : https://leetcode.cn/problems/decode-ways-ii/

// =================================================================================================================================
// 方法1: 暴力递归: 这里没有取模,即使取模也会超时.

#include <string.h>
// s[i...]有多少种有效的转化
int f1(char *s, int n, int i)
{
    if (i == n)
    {
        return 1;
    }
    else
    {
        if (s[i] == '0')
        {
            return 0;
        }
        else // s[i] != '0'
        {
            int ans = 0;

            // i位置想单独转换 ---> i位置要么是* 要么是1~9中的一个数
            ans += f1(s, n, i + 1) * ((s[i] == '*') ? 9 : 1);

            // i想拉着i+1一起转换
            if (i + 1 < n) // 保证有i+1位置
            {
                if (s[i] != '*') // s[i]不是'*',是具体的数字
                {
                    if (s[i + 1] != '*') // s[i+1]位置也是具体数字
                    {
                        if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26)) // 组成的2位数在10到26之间.
                        {
                            ans += f1(s, n, i + 2);
                        }
                        else // 组成的2位数大于26
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                    else // i位置是一个具体的数字; i+1 位置是一个'*'
                    {
                        if (s[i] == '1') // 是 11到19的任意一个数
                        {
                            ans += f1(s, n, i + 2) * 9; // 9种可能
                        }
                        else if (s[i] == '2') // 是21到26的任意一个数
                        {
                            ans += f1(s, n, i + 2) * 6; // 6种可能
                        }
                        else // 是31以及以后的数字
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                }
                else // i位置的字符是 '*'
                {
                    if (s[i + 1] != '*') // i位置是* i+1位置是一个确定的数字
                    {
                        if (s[i + 1] <= '6') // i+1位置的数在6以内
                        {
                            ans += f1(s, n, i + 2) * 2; // (1,确定的数字)或者(2,确定的数字) 2种可能
                        }
                        else // i+1位置的数 可能是 7 8 9
                        {
                            ans += f1(s, n, i + 2); // (1,确定的数字)
                        }
                    }
                    else // i位置是* i+1位置也是*
                    {
                        ans += f1(s, n, i + 2) * 15; // 11到19 | 21到26 ===> 15种情况
                    }
                }
            }
            return ans;
        }
    }
}

int numDecodings1(char *s)
{
    int n = strlen(s);
    return f1(s, n, 0);
}

// =================================================================================================================================
// 方法2: 暴力尝试改记忆化搜索  ---> 挂缓存表

long mod = 1000000007;

long f2(char *s, int n, int i, long *dp)
{
    if (i == n) // 越界位置
    {
        return 1; // 返回1中种转换方法
    }
    else // i位置没有越界
    {
        if (dp[i] != -1) // 之前计算过,直接返回
        {
            return dp[i]; // 直接返回
        }
        else // 没有计算过,去展开.
        {
            if (s[i] == '0')
            {
                dp[i] = 0;
                return 0;
            }
            else // s[i] != '0'
            {
                long ans = 0;

                // i位置想单独转换 ---> i位置要么是* 要么是1~9中的一个数
                ans += f2(s, n, i + 1, dp) * ((s[i] == '*') ? 9 : 1);

                // i想拉着i+1一起转换
                if (i + 1 < n) // 保证有i+1位置
                {
                    if (s[i] != '*') // s[i]不是'*',是具体的数字
                    {
                        if (s[i + 1] != '*') // s[i+1]位置也是具体数字
                        {
                            if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26)) // 组成的2位数在10到26之间.
                            {
                                ans += f2(s, n, i + 2, dp);
                            }
                            else // 组成的2位数大于26
                            {
                                ; // 空语句,什么也不执行
                            }
                        }
                        else // i位置是一个具体的数字; i+1 位置是一个'*'
                        {
                            if (s[i] == '1') // 是 11到19的任意一个数
                            {
                                ans += f2(s, n, i + 2, dp) * 9; // 9种可能
                            }
                            else if (s[i] == '2') // 是21到26的任意一个数
                            {
                                ans += f2(s, n, i + 2, dp) * 6; // 6种可能
                            }
                            else // 是31以及以后的数字
                            {
                                ; // 空语句,什么也不执行
                            }
                        }
                    }
                    else // i位置的字符是 '*'
                    {
                        if (s[i + 1] != '*') // i位置是* i+1位置是一个确定的数字
                        {
                            if (s[i + 1] <= '6') // i+1位置的数在6以内
                            {
                                ans += f2(s, n, i + 2, dp) * 2; // (1,确定的数字)或者(2,确定的数字) 2种可能
                            }
                            else // i+1位置的数 可能是 7 8 9
                            {
                                ans += f2(s, n, i + 2, dp); // (1,确定的数字)
                            }
                        }
                        else // i位置是* i+1位置也是*
                        {
                            ans += f2(s, n, i + 2, dp) * 15; // 11到19 | 21到26 ===> 15种情况
                        }
                    }
                }
                ans = ans % mod; // 取模之后
                dp[i] = ans;     // 挂到缓存表
                return ans;      // 返回ans.
            }
        }
    }
}

int numDecodings2(char *s)
{
    int n = strlen(s);
    long dp[n];
    memset(dp, -1, sizeof(dp)); // 一开始都初始化为-1,表示没有计算过;
    return f2(s, n, 0, dp);
}

// =================================================================================================================================
// 方法3: 严格位置依赖的动态规划

int numDecodings3(char *s)
{
    int n = strlen(s);
    long dp[n + 1];

    dp[n] = 1;
    for (int i = n - 1; i >= 0; i--)
    {
        if (s[i] == '0')
        {
            dp[i] = 0;
        }
        else // s[i] != '0'
        {
            long ans = 0;

            // i位置想单独转换 ---> i位置要么是* 要么是1~9中的一个数
            ans += dp[i + 1] * ((s[i] == '*') ? 9 : 1);

            // i想拉着i+1一起转换
            if (i + 1 < n) // 保证有i+1位置
            {
                if (s[i] != '*') // s[i]不是'*',是具体的数字
                {
                    if (s[i + 1] != '*') // s[i+1]位置也是具体数字
                    {
                        if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26)) // 组成的2位数在10到26之间.
                        {
                            ans += dp[i + 2];
                        }
                        else // 组成的2位数大于26
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                    else // i位置是一个具体的数字; i+1 位置是一个'*'
                    {
                        if (s[i] == '1') // 是 11到19的任意一个数
                        {
                            ans += dp[i + 2] * 9; // 9种可能
                        }
                        else if (s[i] == '2') // 是21到26的任意一个数
                        {
                            ans += dp[i + 2] * 6; // 6种可能
                        }
                        else // 是31以及以后的数字
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                }
                else // i位置的字符是 '*'
                {
                    if (s[i + 1] != '*') // i位置是* i+1位置是一个确定的数字
                    {
                        if (s[i + 1] <= '6') // i+1位置的数在6以内
                        {
                            ans += dp[i + 2] * 2; // (1,确定的数字)或者(2,确定的数字) 2种可能
                        }
                        else // i+1位置的数 可能是 7 8 9
                        {
                            ans += dp[i + 2]; // (1,确定的数字)
                        }
                    }
                    else // i位置是* i+1位置也是*
                    {
                        ans += dp[i + 2] * 15; // 11到19 | 21到26 ===> 15种情况
                    }
                }
            }
            ans = ans % mod; // 取模之后
            dp[i] = ans;     // 挂到缓存表
        }
    }
    return (int)dp[0];
}

// 测试链接 : https://leetcode.cn/problems/decode-ways-ii/
// ========================================================================================
// 方法4: 严格位置依赖的动态规划 + 空间压缩

int numDecodings4(char *s)
{
    int n = strlen(s);
    long cur = 0, next = 1, next_next = 0;
    for (int i = n - 1, cur; i >= 0; i--)
    {
        if (s[i] == '0')
        {
            cur = 0;
        }
        else // s[i] != '0'
        {
            long ans = 0;

            // i位置想单独转换 ---> i位置要么是* 要么是1~9中的一个数
            ans += next * ((s[i] == '*') ? 9 : 1);

            // i想拉着i+1一起转换
            if (i + 1 < n) // 保证有i+1位置
            {
                if (s[i] != '*') // s[i]不是'*',是具体的数字
                {
                    if (s[i + 1] != '*') // s[i+1]位置也是具体数字
                    {
                        if ((i + 1 < n) && ((s[i] - '0') * 10 + (s[i + 1] - '0') <= 26)) // 组成的2位数在10到26之间.
                        {
                            ans += next_next;
                        }
                        else // 组成的2位数大于26
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                    else // i位置是一个具体的数字; i+1 位置是一个'*'
                    {
                        if (s[i] == '1') // 是 11到19的任意一个数
                        {
                            ans += next_next * 9; // 9种可能
                        }
                        else if (s[i] == '2') // 是21到26的任意一个数
                        {
                            ans += next_next * 6; // 6种可能
                        }
                        else // 是31以及以后的数字
                        {
                            ; // 空语句,什么也不执行
                        }
                    }
                }
                else // i位置的字符是 '*'
                {
                    if (s[i + 1] != '*') // i位置是* i+1位置是一个确定的数字
                    {
                        if (s[i + 1] <= '6') // i+1位置的数在6以内
                        {
                            ans += next_next * 2; // (1,确定的数字)或者(2,确定的数字) 2种可能
                        }
                        else // i+1位置的数 可能是 7 8 9
                        {
                            ans += next_next; // (1,确定的数字)
                        }
                    }
                    else // i位置是* i+1位置也是*
                    {
                        ans += next_next * 15; // 11到19 | 21到26 ===> 15种情况
                    }
                }
            }
            ans = ans % mod; // 取模之后
            cur = ans;       // 挂到缓存表
        }
        next_next = next;
        next = cur;
        cur = 0;
    }
    return (int)next;
}
