#include <stdio.h>
#include <string.h>

// =================================================================
// ? 博弈论:牛牛吃草问题
// -----------------------------------------------------------------
// 规则:
// 1. 两个人(A和B)轮流吃草,A先手。
// 2. 每次只能吃 4的幂次方 份草 (1, 4, 16, 64, 256...)
// 3. 谁没草吃了(面对 0),谁就输了。
// =================================================================

// ? 方法一:暴力递归 (DFS - 深度优先搜索)
// 用于验证小数据的规律,数据大了会极慢
char dfs(int rest, char cur)
{
    // 计算对手是谁
    char enemy = (cur == 'A') ? 'B' : 'A';

    // ? 递归边界 (Base Case)
    // 根据题意列举小于 5 的情况：
    // 0: 没草了,当前玩家输 -> Enemy赢
    // 1: 吃1份剩0,当前玩家赢 -> Cur赢
    // 2: 吃1剩1(对手赢),只能输 -> Enemy赢 (不能吃4,因为2<4)
    // 3: 吃1剩2(对手输),当前玩家赢 -> Cur赢
    // 4: 吃4剩0,当前玩家赢 -> Cur赢
    if (rest < 5)
    {
        return ((rest == 0) || (rest == 2)) ? enemy : cur;
    }

    // ? 尝试所有可能的吃法 (1, 4, 16...)
    int pick = 1;
    while (pick <= rest)
    {
        // 如果有一种吃法,让剩下的局面导致(对手输了=我是赢家)
        // 那么我就选这种吃法，直接返回我赢
        if (dfs(rest - pick, enemy) == cur)
        {
            return cur;
        }
        // 尝试下一个 4 的幂 (1 -> 4 -> 16 -> 64...)
        // 注意:这里需要防止整数溢出,但在本题逻辑范围内通常还好
        if (rest / 4 < pick)
            break;
        pick *= 4;
    }

    // ? 如果试遍了所有吃法,无论怎么吃,对手都能赢
    // 那么当前玩家必输
    return enemy;
}

// ? 包装函数:A 先手
char winner_dfs(int n)
{
    return dfs(n, 'A');
}

// =================================================================
// ? 方法二:数学规律 (O(1) 极速解法)
// -----------------------------------------------------------------
// 通过观察 DFS 的结果,或者数学推导得出:
// 模 5 为 0 或 2 时,先手必输.
// =================================================================
char winner_math(int n)
{
    // ? 规律:
    // n % 5 == 0 (0, 5, 10...) -> B赢 (A输)
    // n % 5 == 1 (1, 6, 11...) -> A赢
    // n % 5 == 2 (2, 7, 12...) -> B赢 (A输)
    // n % 5 == 3 (3, 8, 13...) -> A赢
    // n % 5 == 4 (4, 9, 14...) -> A赢

    if ((n % 5 == 0) || (n % 5 == 2))
    {
        return 'B'; // 先手必输
    }
    else
    {
        return 'A'; // 先手必胜
    }
}

int main()
{
    int i = 0;
    printf("? 开始对比测试 (前 50 组数据)...\n");
    printf("草数量 | DFS结果 | Math结果 | 验证\n");
    printf("------------------------------------\n");

    for (i = 0; i < 50; i++)
    {
        char res_dfs = winner_dfs(i);
        char res_math = winner_math(i);

        printf(" %3d   |    %c    |    %c     |  %s\n",
               i, res_dfs, res_math,
               (res_dfs == res_math) ? "对" : "错");
    }

    return 0;
}
