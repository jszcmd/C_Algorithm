#include <stdio.h>
#include <limits.h> // 用于使用 INT_MAX (整数最大值)

// =================================================================
// ? 方法一:暴力递归 (DFS - 深度优先搜索)
// -----------------------------------------------------------------
// rest: 剩余需要装的苹果数量
// 返回值: 能够装满 rest 个苹果所需的最少袋子数,无法装满返回 INT_MAX
// =================================================================
int dfs(int rest)
{
    // ? 递归边界 1: 剩余苹果数小于 0
    // 说明之前的减法减多了(比如剩 4 个苹果,却用了 6 号袋),此路不通
    if (rest < 0)
    {
        return INT_MAX; // 返回最大整数,表示无效解
    }

    // ? 递归边界 2: 剩余苹果数正好为 0
    // 说明正好装完,不需要额外的袋子了
    if (rest == 0)
    {
        return 0;
    }

    // ? 分支 1: 尝试使用一个 8 规格的袋子
    // 递归计算：(剩余 - 8) 个苹果还需要多少袋子
    int p1 = dfs(rest - 8);

    // ? 分支 2: 尝试使用一个 6 规格的袋子
    // 递归计算：(剩余 - 6) 个苹果还需要多少袋子
    int p2 = dfs(rest - 6);

    // ? 结果处理:
    // 如果 p1 是有效解 (不是 INT_MAX)，则总袋数 = p1 + 1 (当前这只袋子)
    // 否则,保持 INT_MAX 不变
    p1 += (p1 != INT_MAX) ? 1 : 0;

    // 同理处理 p2
    p2 += (p2 != INT_MAX) ? 1 : 0;

    // ?? 择优录取:返回两种方案中袋子更少的那一个
    return (p1 < p2) ? p1 : p2;
}

// ? 包装函数
// 负责调用 dfs 并将 INT_MAX 转换为题目要求的 -1
int bag_bfs(int n)
{
    // 这里调用改名后的 dfs 函数
    int ans = dfs(n);
    // 如果 ans 还是 INT_MAX,说明尝试了所有可能都无法正好装满,返回 -1
    return (ans == INT_MAX) ? -1 : ans;
}

// =================================================================
// ? 方法二：数学规律 (O(1) 极速解法)
// -----------------------------------------------------------------
// 这里的逻辑是根据暴力求解的结果找出的规律
// =================================================================
int bags_math(int apples)
{
    // ? 奇数判断:6和8都是偶数,无法凑出奇数
    if (apples % 2 != 0)
    {
        return -1;
    }
    // ? 小数区间处理 (<18)
    // 18 是一个分界线 (6+6+6),小于 18 的偶数情况比较特殊，直接枚举
    else if (apples < 18)
    {
        if (apples == 0)
            return 0; // 0个苹果0个袋 (虽然题目通常要求正整数,但逻辑上是0)

        // 6, 8 -> 1袋
        if ((apples == 6) || (apples == 8))
        {
            return 1;
        }
        // 12(6+6), 14(6+8), 16(8+8) -> 2袋
        else if ((apples == 12) || (apples == 14) || (apples == 16))
        {
            return 2;
        }
        // 其他偶数 (2, 4, 10) 无法凑出 -> -1
        else
        {
            return -1;
        }
    }
    // ? 大数区间通用公式 (>=18)
    // 规律:每增加 8 个苹果,袋子数加 1
    else
    {
        return (apples - 18) / 8 + 3;
    }
}

int main()
{
    int i = 0;
    printf("开始测试...\n");
    printf("格式: [苹果数量] :: [结果是否一致(1=一致, 0=不一致)]\n");

    // ?? 注意:由于 dfs 是暴力递归,没有记忆化(Memoization)
    // 当数字超过 60 或 70 时,计算速度会极慢甚至看起来像死机。
    // 为了演示流畅,建议先测试到 50 左右.如果想测 100,需要很长时间。
    for (i = 1; i <= 50; i++)
    {
        // 这里比较两个函数的返回值是否相等
        // 打印 1 表示两个算法结果一致(True),打印 0 表示不一致(False)
        int check = (bag_bfs(i) == bags_math(i));

        printf("%d个苹果 :: %d\n", i, check);
    }

    return 0;
}
