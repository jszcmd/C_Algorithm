/*
 * ================================================================================
 * 📘 题目: 928. 尽量减少恶意软件的传播 II (Minimize Malware Spread II)
 * 🔗 链接: https://leetcode.cn/problems/minimize-malware-spread-ii/
 * 📈 难度: 困难 (Hard)
 * --------------------------------------------------------------------------------
 * 📝 【题目描述】
 * 给定一个由 n 个节点组成的网络,用 n x n 个邻接矩阵 graph 表示.在节点网络中，
 * 只有当 graph[i][j] = 1 时,节点 i 能够直接连接到另一个节点 j.
 * 一些节点 initial 最初被恶意软件感染.只要两个节点直接连接,且其中至少一个节点
 * 受到恶意软件的感染,那么两个节点都将被恶意软件感染.这种恶意软件的传播将继续,
 * 直到没有更多的节点可以被这种方式感染.
 * 假设 M(initial) 是在恶意软件停止传播之后,整个网络中感染恶意软件的最终节点数.
 * 我们可以从 initial 中删除一个节点,并完全移除该节点以及该节点到任何其他节点
 * 的任何连接.
 * 请返回移除后能够使 M(initial) 最小化的节点.如果有多个节点满足条件,返回索引
 * 最小的节点.
 * --------------------------------------------------------------------------------
 * 🌟 【示例 1】
 * 输入: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] -> 输出: 0
 * 🌟 【示例 2】
 * 输入: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] -> 输出: 1
 * 🌟 【示例 3】
 * 输入: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] -> 输出: 1
 * --------------------------------------------------------------------------------
 * 📏 【提示】
 * • n == graph.length
 * • 2 <= n <= 300
 * • graph[i][j] 是 0 或 1,graph[i][i] == 1
 * • 1 <= initial.length < n
 * • 0 <= initial[i] <= n - 1
 * ================================================================================
 */

// ----------------------------- 全局定义模块 -----------------------------
#include <stdbool.h> // 🛠️ 引入布尔类型：支持 virus 数组的 true/false 标记
#include <stdlib.h>  // 使用qsort()函数

#define MAX 301 // 📏 限制定义:题目规定节点总数 N 不超过 300

bool virus[MAX]; // ☣️ 病毒名册:记录哪些节点是初始的"带毒者"

int cnts[MAX]; // 🛡️ 功劳簿:记录如果删掉某个初始病毒,总共能救回多少个健康点

int infect[MAX]; // 🛡️ 溯源核心:实时记录每个健康连通块被哪些病毒"监测"或"威胁"
// 🧬 集合特征标记:利用并查集的根节点,动态追踪该区域的"风险等级"与"感染源头"
// --------------------------------
// ⚪ 状态 -1 :【绝对安全】 目前该健康连通块尚未接触到任何初始病毒源
// ☣️ 状态 >=0:【单源威胁】 该区域仅与唯一的初始病毒 (值为该病毒索引) 相连,移除此源头即可拯救全区
// 🛑 状态 -2 :【交叉感染】 该区域被 2 个或更多不同病毒源包围,移除单个病毒无法改变被感染的命运
// --------------------------------

int father[MAX]; // 🌳 族谱图:并查集核心,存放每个节点的父节点

int size[MAX]; // 📊 规模表:存放每一个健康连通块里总共有多少个节点

// 集合一定只放普通点,病毒源头点根本不参数与集合,也不是元素

// ----------------------------- 初始化模块 -----------------------------

void build(int n, int *initial, int initialSize)
{
    for (int i = 0; i < n; i++)
    {
        virus[i] = false; // 🏗️ 初始化:先假设所有人都是健康的
        cnts[i] = 0;      // 🏗️ 初始化:所有病毒的拯救贡献初始为 0
        infect[i] = -1;   // 🏗️ 初始化:所有区域初始都是"未受威胁"状态
        size[i] = 1;      // 🏗️ 初始化:每个节点初始自成一派,大小为 1
        father[i] = i;    // 🏗️ 初始化:每个节点的祖先暂时都是自己
    }
    for (int i = 0; i < initialSize; i++)
    {
        virus[initial[i]] = true; // 🧪 确诊标记:根据输入名单,把真正的病毒节点标记出来
    }
}

// ----------------------------- 并查集核心模块 -----------------------------

int find(int i)
{
    if (i != father[i]) // 🔍 判断:如果我的父节点不是我自己,说明我上面还有"老大"
    {
        father[i] = find(father[i]); // 🚀 递归并路径压缩:直接认"最高祖先"当爹,提高以后查询速度
    }
    return father[i]; // 🎯 返回:最终找到的最顶层祖先(代表节点)
}

void do_union(int x, int y)
{
    int fx = find(x); // 📍 找到 x 所在团伙的最高负责人
    int fy = find(y); // 📍 找到 y 所在团伙的最高负责人
    if (fx != fy)     // 🤝 判断:如果两者的负责人不是同一个人,说明它们还不属于同一个团伙
    {
        father[fx] = fy;      // 🔗 合并:让 x 的负责人认 y 的负责人当老大,两个团伙合并
        size[fy] += size[fx]; // 📈 扩容:新团伙的总人数等于两个旧团伙人数之和
    }
}

// ----------------------------- 回调工具模块 -----------------------------

int int_cmp(const void *e1, const void *e2)
{
    return (*(int *)e1) - (*(int *)e2); // ⚖️ 比较规则:数值小的排前面,用于排序初始病毒数组
}

// ----------------------------- 主算法逻辑模块 -----------------------------

int minMalwareSpread(int **graph, int graphSize, int *graphColSize, int *initial, int initialSize)
{
    int n = graphSize;
    build(n, initial, initialSize); // 🏗️ 步骤1:搭建基础数据环境
    // 只要不是病毒,是普通点,该合并就去合并
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (graph[i][j] == 1 && !virus[i] && !virus[j]) // 🔗 判断:如果 i 和 j 有连线,且两个都不是病毒
            {
                do_union(i, j); // 🤝 合并:把这两个连通的健康人划入同一个"纯净区域"
            }
        }
    }

    // 病毒周围的普通点的那个集合去设置源头
    for (int i = 0, sick; i < initialSize; i++)
    {
        sick = initial[i]; // ☣️ 锁定:当前正在观察的这个初始病毒节点
        for (int neighbor = 0; neighbor < n; neighbor++)
        {
            if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1) // 📡 判断:如果是该病毒的邻居,且邻居是健康人
            {
                int fn = find(neighbor); // 📡 探测:找到这个健康邻居所属的整个"纯净区域"的老大
                if (infect[fn] == -1)    // 🛡️ 判断:如果这个纯净区域之前还没被任何病毒标记过
                {
                    infect[fn] = sick; // 🔍 记录:这是第一个发现能感染该区域的病毒
                }
                else if (infect[fn] != -2 && infect[fn] != sick) // ⚡ 判断:如果已经有其他病毒盯上这块区域了
                {
                    infect[fn] = -2; // 🛑 报废:多源感染,删掉一个也救不活它
                }
            }
        }
    }

    // 统计拯救数据  只讨论代表节点,因为代表节点存储这集合中的元素数量.
    for (int i = 0; i < n; i++)
    {
        if (i == find(i) && infect[i] >= 0) // 📈 判断:如果 i 是区域老大,且该区域只被唯一一个病毒威胁
        {
            cnts[infect[i]] += size[i]; // ✅ 记功:把这个区域的所有人数都算在该病毒的"拯救额度"里
        }
    }

    qsort(initial, initialSize, sizeof(initial[0]), int_cmp); // ⏱️ 步骤2:对病毒编号排序,方便查找最小值

    int ans = initial[0]; // 🏁 初始设定:默认第一个病毒为最终答案
    int max = cnts[ans];  // 📊 记录:当前最高能拯救的人数
    for (int i = 0; i < initialSize; i++)
    {
        if (cnts[initial[i]] > max) // 🏆 判断:如果发现另一个病毒移除后拯救效果更好
        {
            ans = initial[i];       // ✅ 更新:记录这个性价比更高的病毒编号
            max = cnts[initial[i]]; // 🚀 刷新:更新目前的最高纪录
        }
    }

    return ans; // 🚀 结果:返回最终方案
}
