# 算法讲解 057【必备】并查集-下

**讲师**：左程云
**前置知识**：讲解 056-并查集-上

---

## 📚 课程简介

本节课主要讲解并查集的更多题目。

### 🛠️ 并查集的小扩展
* **定制信息**：可以定制信息：并查集目前有多少个集合，以及给每个集合打上标签信息。

> ⚠️ **注意**：带权并查集、可持久化并查集、可撤销并查集，都是备战算法竞赛的同学必学的内容。这些内容会在【挺难】阶段的课程里安排讲述。

---

## 📝 题目 1：移除最多的同行或同列石头

**题目链接**：[LeetCode 947](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

### 📖 题目描述
`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。
如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。
给你一个长度为 `n` 的数组 `stones`，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置。
返回 **可以移除的石子** 的最大数量。

### 💻 代码实现

```python
from typing import List

"""
======================================================================================
📝 题目: 947. 移除最多的同行或同列石头 (Most Stones Removed with Same Row or Column)
🔗 链接: https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/
📈 难度: 中等 (Medium)
======================================================================================
【题目描述】
n 块石头放置在二维平面中的一些整数坐标点上.每个坐标点上最多只能有一块石头.

如果一块石头的 "同行或者同列" 上有其他石头存在,那么就可以移除这块石头.

给你一个长度为 n 的数组 stones ,其中 stones[i] = [xi, yi] 表示第 i 块石头的位置,
返回 "可以移除的石子" 的最大数量.

--------------------------------------------------------------------------------------
🌟 【示例 1】
输入: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出: 5
解释: 一种移除 5 块石头的方法如下所示:
1. 移除石头 [2,2] , 因为它和 [2,1] 同行.
2. 移除石头 [2,1] , 因为它和 [0,1] 同列.
3. 移除石头 [1,2] , 因为它和 [1,0] 同列.
4. 移除石头 [1,0] , 因为它和 [0,0] 同列.
5. 移除石头 [0,1] , 因为它和 [0,0] 同行.
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列.

🌟 【示例 2】
输入: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出: 3
解释: 一种移除 3 块石头的方法如下所示:
1. 移除石头 [2,2] , 因为它和 [2,0] 同行.
2. 移除石头 [2,0] , 因为它和 [0,0] 同列.
3. 移除石头 [0,2] , 因为它和 [0,0] 同行.
石头 [0,0] 和 [1,1] 不能移除,因为它们没有与另一块石头同行/列.

🌟 【示例 3】
输入: stones = [[0,0]]
输出: 0
解释: [0,0] 是平面上唯一一块石头,所以不可以移除它.

--------------------------------------------------------------------------------------
📏 【提示】
• 1 <= stones.length <= 1000
• 0 <= xi, yi <= 10^4
• 不会有两块石头放在同一个坐标点上
======================================================================================
"""

# 时间复杂度: O(n)
class Solution:
    # key:是某一行, value是第一次遇到的石头的编号
    rowFirst: dict[int, int] = dict()  # 🗺️ 记录某行第一次出现的石头下标

    # key:是某一列, value是第一次遇到的石头的编号
    colFirst: dict[int, int] = dict()  # 🗺️ 记录某列第一次出现的石头下标

    MAX: int = 1001
    father: list[int] = [0] * MAX      # 🌲 并查集数组
    sets: int = 0                      # 🧩 连通分量(集合)的总数

    def build(self, n: int) -> None:
        self.rowFirst.clear()          # 🧹 清空行记录
        self.colFirst.clear()          # 🧹 清空列记录
        for i in range(n):
            self.father[i] = i         # 🏳️ 初始化:父节点指向自己
        self.sets = n                  # 🔢 初始:每个石头都是一个独立集合

    def find(self, i: int) -> int:
        if i != self.father[i]:        # 🔍 如果不是根节点
            self.father[i] = self.find(self.father[i]) # 🛤️ 路径压缩:直接连到根
        return self.father[i]

    # 把第x块石头和第y块是否合并
    def union(self, x: int, y: int) -> None:
        fx: int = self.find(x)         # 🔍 找 x 的根
        fy: int = self.find(y)         # 🔍 找 y 的根
        if fx != fy:                   # ⚡ 如果根不同,说明还没连通
            self.father[fx] = fy       # 🔗 合并:让 x 的根指向 y 的根
            self.sets -= 1             # 📉 成功合并,集合数量减 1

    def removeStones(self, stones: List[List[int]]) -> int:
        n: int = len(stones)           # 🔢 石头总数
        self.build(n)                  # 🏗️ 初始化并查集
        for i in range(n):
            row: int = stones[i][0]    # ↔️ 当前行坐标
            col: int = stones[i][1]    # ↕️ 当前列坐标
            
            # row in self.rowFirst 判断第row行是否存放过石头
            if not row in self.rowFirst:   # 🆕 如果这行是第一次遇到
                self.rowFirst[row] = i     # 📍 记录当前石头为这行的"代表"
            else:                          # ♻️ 如果这行之前出现过
                self.union(self.rowFirst[row], i) # 🔗 与这行的"代表"合并
            
            # col in self.colFirst 判断第col列是否存放过石头
            if not col in self.colFirst:   # 🆕 如果这列是第一次遇到
                self.colFirst[col] = i     # 📍 记录当前石头为这列的"代表"
            else:                          # ♻️ 如果这列之前出现过
                self.union(self.colFirst[col], i) # 🔗 与这列的"代表"合并
                
        return n - self.sets           # 🏁 结果 = 总石头数 - 连通分量数
    

```

---

## 📝 题目 2：找出知晓秘密的所有专家

**题目链接**：[LeetCode 2092](https://leetcode.cn/problems/find-all-people-with-secret/)

### 📖 题目描述
给你一个整数 `n`，表示有 `n` 个专家从 `0` 到 `n - 1` 编号。
另外给你一个下标从 `0` 开始的二维整数数组 `meetings`，其中 `meetings[i] = [xi, yi, timei]`，表示专家 `xi` 和专家 `yi` 在时间 `timei` 要开一场会。一个专家可以同时参加多场会议。

* 专家 `0` 有一个 **秘密**，最初，他在时间 `0` 将这个秘密分享给了专家 `firstPerson`。
* 秘密会在每次有知晓这个秘密的专家参加会议时进行传播。
* **瞬时发生**：在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。

在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 **任何顺序** 返回答案。

### 💻 代码实现

```c
/*
 * ================================================================================
 * 📘 题目:2092. 找出知晓秘密的所有专家 (Find All People With Secret)
 * 🔗 链接: https://leetcode.cn/problems/find-all-people-with-secret/
 * 📈 难度: 困难 (Hard)
 * --------------------------------------------------------------------------------
 * 📝 【题目描述】
 * 给你一个整数 n ,表示有 n 个专家从 0 到 n - 1 编号.
 * 另外给你一个下标从 0 开始的二维整数数组 meetings ,其中 meetings[i] = [xi, yi, timei]
 * 表示专家 xi 和专家 yi 在时间 timei 要开一场会.一个专家可以同时参加多场会议.
 * 最后,给你一个整数 firstPerson.
 * * 专家 0 有一个秘密,最初,他在时间 0 将这个秘密分享给了专家 firstPerson.
 * 接着,这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播.更正式的表达是:
 * 每次会议,如果专家 xi 在时间 timei 时知晓这个秘密,那么他将会与专家 yi 分享这个
 * 秘密,反之亦然.
 * * ⚡ 秘密共享是 瞬时发生 的.也就是说,在同一时间,一个专家不仅可以接收到秘密,
 * 还能在其他会议上与其他专家分享.
 * 在所有会议都结束后,返回所有知晓这个秘密的专家列表.你可以按 任何顺序 返回答案.
 * --------------------------------------------------------------------------------
 * 🌟 【示例 1】
 * 输入: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 -> 输出: [0,1,2,3,5]
 * 🌟 【示例 2】
 * 输入: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 -> 输出: [0,1,3]
 * 🌟 【示例 3】
 * 输入: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 -> 输出: [0,1,2,3,4]
 * --------------------------------------------------------------------------------
 * 📏 【提示】
 * • 2 <= n <= 10^5
 * • 1 <= meetings.length <= 10^5
 * • meetings[i].length == 3
 * • 0 <= xi, yi <= n - 1 且 xi != yi
 * • 1 <= timei <= 10^5
 * • 1 <= firstPerson <= n - 1
 * ================================================================================
 */

#include <stdlib.h>  // 🛠️ 使用qsort()和malloc()函数
#include <stdbool.h> // 使用bool数据类型

#define MAX 100001 // 📏 定义最大专家数量限制

int father[MAX]; // 🌳 并查集:存储每个节点的父节点

bool secret[MAX] = {false}; // 🔐 秘密状态：标记该集合是否知晓秘密
// 🧬 集合的标签信息:设置集合的一些属性,
// 🔍 属性在哪里? secret[代表元素] 代表集合的属性

void build(int n, int first)
{
    for (int i = 0; i < n; i++)
    {
        father[i] = i;     // 🆔 初始化:每个人的父节点是自己
        secret[i] = false; // ⚪ 初始状态:所有人均不知晓秘密
    }
    father[first] = 0; // 🤝 初始链接:将firstPerson与0号专家归为一集
    secret[0] = true;  // 🔑 源头:0时刻0号专家已知晓秘密
}

int find(int i)
{
    if (i != father[i])
    {
        father[i] = find(father[i]); // 🔍 路径压缩:直接指向根节点
    }
    return father[i];
}

void do_union(int x, int y)
{
    int fx = find(x);
    int fy = find(y);
    if (fx != fy)
    {
        father[fx] = fy;          // 🔗 合并:将两个集合连通
        secret[fy] |= secret[fx]; // ⚡ 传播:只要有一个集合知晓,合并后全集知晓
    }
}

// ⚖️ 比较函数
int time_cmp(const void *e1, const void *e2)
{
    // 1. 先把 void* 转成 int**
    // 2. 使用 * 进行解引用,获取真正存储会议数据的 int*
    int *arr1 = *(int **)e1;
    int *arr2 = *(int **)e2;

    // 3. 比较第三个元素(时刻)
    return arr1[2] - arr2[2]; // ⏳ 按会议时间升序排列
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int *findAllPeople(int n, int **meetings, int meetingsSize, int *meetingsColSize, int firstPerson, int *returnSize)
{

    build(n, firstPerson); // 🏗️ 初始化并查集:设定所有人父节点为自身,并建立 0 号与初始专家的连接
    // meetings[a,b,c] // 数据结构说明:a,b 为专家编号,c 为会议时刻

    // m:表示一共开了机场会议
    int m = meetingsSize;                              // 📝 缓存会议总数:避免在循环中多次读取变量
    qsort(meetings, m, sizeof(meetings[0]), time_cmp); // ⏱️ 时序排序:严格按照会议发生的时间戳 c 进行升序排列
    for (int l = 0, r; l < m;)
    {
        r = l; // 📍 窗口起点:标记当前处理的时间段起始索引
        // l...r这些会议,一定是共同时刻
        while (r + 1 < m && meetings[l][2] == meetings[r + 1][2])
        {
            r++; // 🔍 同时性识别:将所有在同一时刻 c 发生的会议划分为一个批次处理
        }
        for (int i = l; i <= r; i++)
        {
            do_union(meetings[i][0], meetings[i][1]); // 📡 秘密传播:在当前时刻,所有开会的人员在并查集中建立连通关系
        }
        // 合并在一起知道秘密的人,不用拆散
        for (int i = l, a, b; i <= r; i++)
        {
            a = meetings[i][0]; // 👤 提取人员 A:获取当前批次会议中的第一位专家
            b = meetings[i][1]; // 👤 提取人员 B:获取当前批次会议中的第二位专家
            if (!secret[find(a)])
            {
                father[a] = a; // 🚫 逻辑回滚:若 A 所在的集合最终没能连接到秘密源,则撤销其在并查集中的连接
            }
            if (!secret[find(b)])
            {
                father[b] = b; // 🚫 逻辑回滚:确保只有在该时刻学到秘密的人,才能将秘密带入下一时刻
            }
        }
        l = r + 1; // ⏭️ 批次更替:移动左指针,准备处理下一个不同时刻的会议组
    }
    int count = 0; // 🔢 计数器:准备统计全城最终知晓秘密的总人数
    for (int i = 0; i < n; i++)
    {
        if (secret[find(i)] == true)
        {
            count++;          // 📊 深度检索:检查每个专家所属集合的根节点是否标记为"知秘"状态
            secret[i] = true; // 那么我们就顺便把第i位专家直接改成知道秘密
        }
    }
    int *ans = (int *)malloc(sizeof(int) * count); // 💾 空间分配:根据统计人数动态申请返回数组的内存
    for (int i = 0, cur = 0; i < n; i++)
    {
        if (secret[i] == true) // 上面我们已经直接修改secret[i] = true了
        {
            ans[cur++] = i; // ✅ 名单录入:按编号顺序将所有知晓秘密的专家存入结果数组
        }
    }
    *returnSize = count; // 🏁 长度回传:通过指针告知调用方结果数组的有效长度
    return ans;          // 🚀 成果提交:返回最终生成的知情专家名单指针
}
```



## 📝 题目 3：好路径的数目

**题目链接**：[LeetCode 2421](https://leetcode.cn/problems/number-of-good-paths/)

### 📖 题目描述
给你一棵 `n` 个节点的树（连通无向无环的图），节点编号从 `0` 到 `n-1`，且恰好有 `n-1` 条边。
给你一个长度为 `n` 的整数数组 `vals` 分别表示每个节点的值。同时给你一个二维整数数组 `edges`，其中 `edges[i] = [ai, bi]` 表示节点 `ai` 和 `bi` 之间有一条 **无向** 边。

**好路径** 需要满足以下条件：

1.  开始节点和结束节点的值 **相同**。
2.  路径中所有节点的值都 **小于等于** 开始节点的值（即开始节点的值是路径上的最大值）。

**注意**：
* 一条路径和它反向的路径算作 **同一** 路径（例如 `0 -> 1` 与 `1 -> 0` 视为同一条）。
* 单个节点也视为一条合法路径。

### 💻 代码实现

```c
/*
 * ======================================================================================
 * 📘 题目: 2421. 好路径的数目 (Number of Good Paths)
 * 🔗 链接: https://leetcode.cn/problems/number-of-good-paths/
 * 📈 难度: 困难 (Hard)
 * ======================================================================================
 *
 * 📝 【题目描述】
 * 给你一棵 n 个节点的树(连通无向无环的图),节点编号从 0 到 n - 1 且恰好有 n - 1 条边.
 * 给你一个长度为 n 下标从 0 开始的整数数组 vals ,分别表示每个节点的值.
 * 同时给你一个二维整数数组 edges ,其中 edges[i] = [a, b] 表示节点 a 和 b 之间有一条 无向 边.
 *
 * 一条 "好路径" 需要满足以下条件:
 * 1. ✨ 开始节点和结束节点的值 相同 .
 * 2. 🏔️ 开始节点和结束节点中间的所有节点值都 小于等于 开始节点的值
 * (也就是说开始节点的值应该是路径上所有节点的最大值).
 *
 * 请你返回不同好路径的数目.
 *
 * 注意:一条路径和它反向的路径算作 同一 路径.比方说， 0 -> 1 与 1 -> 0 视为同一条路径.
 * 单个节点也视为一条合法路径.
 *
 * --------------------------------------------------------------------------------------
 * 🌟 【示例 1】
 * 输入:vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
 * 输出:6
 * 解释:总共有 5 条单个节点的好路径。
 * 还有 1 条好路径:1 -> 0 -> 2 -> 4 。
 * (反方向的路径 4 -> 2 -> 0 -> 1 视为跟 1 -> 0 -> 2 -> 4 一样的路径)
 * 注意 0 -> 2 -> 3 不是一条好路径,因为 vals[2] > vals[0] .
 *
 * 🌟 【示例 2】
 * 输入:vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
 * 输出:7
 * 解释:总共有 5 条单个节点的好路径.
 * 还有 2 条好路径：0 -> 1 和 2 -> 3 .
 *
 * 🌟 【示例 3】
 * 输入:vals = [1], edges = []
 * 输出:1
 * 解释:这棵树只有一个节点,所以只有一条好路径.
 *
 * --------------------------------------------------------------------------------------
 * 📏 【提示】
 * • n == vals.length
 * • 1 <= n <= 3 * 10^4
 * • 0 <= vals[i] <= 10^5
 * • edges.length == n - 1
 * • edges[i].length == 2
 * • 0 <= a, b < n
 * • edges 表示一棵合法的树
 * ======================================================================================
 */

#include <stdlib.h> // 使用qsort()函数 // 🛠️ 引入标准库：执行高效的 qsort 排序算法
#define MAX 30001   // 📏 限制定义:根据题目要求设定节点数上限

// 需要保证集合中,代表节点的值,一定是整个集合的最大值
int father[MAX]; // 🌳 并查集数组:管理节点间的连通性

int maxcnt[MAX]; // 🔢 计数器:在根节点记录当前集合内"最大值"出现的次数
// 整个集合中有几个最大值,还是存放在代表节点的位置

int vals_arr[MAX]; // 原始的数据,定义成全局变量,方便传参 // 💾 数据镜像:存储节点分值以便在排序回调中快速访问

void build(int n)
{
    for (int i = 0; i < n; i++)
    {
        father[i] = i; // 🏗️ 初始化:每个节点初始父节点指向自身
        maxcnt[i] = 1; // 🏗️ 初始化:每个集合初始仅包含自己,最大值出现 1 次
    }
}

int find(int i)
{
    if (i != father[i])
    {
        father[i] = find(father[i]); // 🔍 路径压缩:递归查找根节点并扁平化树结构,优化后续查询
    }
    return father[i]; // 🎯 返回集合的"行政中心"(根节点)
}

int do_union(int x, int y)
{
    // fx: x所在集团的代表节点,同时也是x所在集团的最大值下标
    int fx = find(x); // 📍 定位:找到包含节点 x 的集合根节点
    // fy: y所在集团的代表节点,同时也是y所在集团的最大值下标
    int fy = find(y);                // 📍 定位:找到包含节点 y 的集合根节点
    int path = 0;                    // 产生好路劲的条数 // 📈 初始化新增路径贡献
    if (vals_arr[fx] > vals_arr[fy]) // 两个集团最大值不一样,不会有好路径的;
    {
        father[fy] = fx; // 🔗 吞并:小值集合并入大值集合,大值集合特征不变
    }
    else if (vals_arr[fx] < vals_arr[fy])
    {
        father[fx] = fy; // 🔗 吞并:小值集合并入大值集合,大值集合特征不变
    }
    else // 两个集团最大值一样
    {
        path = maxcnt[fx] * maxcnt[fy]; // ✨ 排列组合:两集合最大值相同,可产生 n1 * n2 条新好路径
        father[fy] = fx;                // 🤝 合并:将两个势均力敌的集合合二为一
        maxcnt[fx] += maxcnt[fy];       // 📈 累加:更新合并后新集合中最大值的总出现次数
    }
    return path; // 🚀 返回本次合并操作对全局答案的增量贡献
}

int max(int a, int b)
{
    return (a > b) ? a : b; // ⚖️ 辅助工具:返回两个整数中的较大者
}

int arr_cmp(const void *e1, const void *e2)
{
    int *arr1 = *(int **)e1; // 数组1 // 📑 解析:获取第一条边的数据指针
    int *arr2 = *(int **)e2; // 数组2 // 📑 解析:获取第二条边的数据指针

    int max1 = max(vals_arr[arr1[0]], vals_arr[arr1[1]]); // 🔍 探测:计算边 1 两端节点的最大分值
    int max2 = max(vals_arr[arr2[0]], vals_arr[arr2[1]]); // 🔍 探测:计算边 2 两端节点的最大分值

    return max1 - max2; // // ⏱️ 排序策略:按边的"最大端点值"升序排列,满足路径值不超端点的约束
}

int numberOfGoodPaths(int *vals, int valsSize, int **edges, int edgesSize, int *edgesColSize)
{
    int n = valsSize; // 📊 节点总规模
    build(n);         // 🏗️ 步骤1:初始化并查集
    for (int i = 0; i < n; i++)
    {
        vals_arr[i] = vals[i]; // 📝 步骤2:备份数值到全局数组方便回调查询
    }
    // 核心排序
    qsort(edges, edgesSize, sizeof(edges[0]), arr_cmp); // ⏱️ 步骤3:核心排序,确保从小到大动态构图

    int ans = n; // 🚀 步骤4:基础计数,每个单节点本身即为一条"好路径"
    for (int i = 0; i < edgesSize; i++)
    {
        ans += do_union(edges[i][0], edges[i][1]); // 📡 步骤5:遍历边,动态维护集合并累加新发现的路径
    }
    return ans; // 🏁 返回最终计算的总好路径数目
}
```



## 📝 题目 4：尽量减少恶意软件的传播 II

**题目链接**：[LeetCode 928](https://leetcode.cn/problems/minimize-malware-spread-ii/)

### 📖 题目描述
给定一个由 `n` 个节点组成的网络，一定是无向图，用 `n * n` 个邻接矩阵 `graph` 表示。
在节点网络中，只有当 `graph[i][j] = 1` 时，节点 `i` 能够直接连接到另一个节点 `j`。

* 一些节点 `initial` 最初被恶意软件感染。
* 只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
* 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。

假设 `M(initial)` 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
我们可以从 `initial` 中 **完全移除一个节点**，并完全移除该节点以及从该节点到任何其他节点的任何连接。

请返回移除后能够使 `M(initial)` **最小化** 的节点。
如果有多个节点满足条件，返回索引 **最小的节点**。`initial` 中每个整数都不同。

### 💻 代码实现

```c
/*
 * ================================================================================
 * 📘 题目: 928. 尽量减少恶意软件的传播 II (Minimize Malware Spread II)
 * 🔗 链接: https://leetcode.cn/problems/minimize-malware-spread-ii/
 * 📈 难度: 困难 (Hard)
 * --------------------------------------------------------------------------------
 * 📝 【题目描述】
 * 给定一个由 n 个节点组成的网络,用 n x n 个邻接矩阵 graph 表示.在节点网络中，
 * 只有当 graph[i][j] = 1 时,节点 i 能够直接连接到另一个节点 j.
 * 一些节点 initial 最初被恶意软件感染.只要两个节点直接连接,且其中至少一个节点
 * 受到恶意软件的感染,那么两个节点都将被恶意软件感染.这种恶意软件的传播将继续,
 * 直到没有更多的节点可以被这种方式感染.
 * 假设 M(initial) 是在恶意软件停止传播之后,整个网络中感染恶意软件的最终节点数.
 * 我们可以从 initial 中删除一个节点,并完全移除该节点以及该节点到任何其他节点
 * 的任何连接.
 * 请返回移除后能够使 M(initial) 最小化的节点.如果有多个节点满足条件,返回索引
 * 最小的节点.
 * --------------------------------------------------------------------------------
 * 🌟 【示例 1】
 * 输入: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] -> 输出: 0
 * 🌟 【示例 2】
 * 输入: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] -> 输出: 1
 * 🌟 【示例 3】
 * 输入: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] -> 输出: 1
 * --------------------------------------------------------------------------------
 * 📏 【提示】
 * • n == graph.length
 * • 2 <= n <= 300
 * • graph[i][j] 是 0 或 1,graph[i][i] == 1
 * • 1 <= initial.length < n
 * • 0 <= initial[i] <= n - 1
 * ================================================================================
 */

// ----------------------------- 全局定义模块 -----------------------------
#include <stdbool.h> // 🛠️ 引入布尔类型：支持 virus 数组的 true/false 标记
#include <stdlib.h>  // 使用qsort()函数

#define MAX 301 // 📏 限制定义:题目规定节点总数 N 不超过 300

bool virus[MAX]; // ☣️ 病毒名册:记录哪些节点是初始的"带毒者"

int cnts[MAX]; // 🛡️ 功劳簿:记录如果删掉某个初始病毒,总共能救回多少个健康点

int infect[MAX]; // 🛡️ 溯源核心:实时记录每个健康连通块被哪些病毒"监测"或"威胁"
// 🧬 集合特征标记:利用并查集的根节点,动态追踪该区域的"风险等级"与"感染源头"
// --------------------------------
// ⚪ 状态 -1 :【绝对安全】 目前该健康连通块尚未接触到任何初始病毒源
// ☣️ 状态 >=0:【单源威胁】 该区域仅与唯一的初始病毒 (值为该病毒索引) 相连,移除此源头即可拯救全区
// 🛑 状态 -2 :【交叉感染】 该区域被 2 个或更多不同病毒源包围,移除单个病毒无法改变被感染的命运
// --------------------------------

int father[MAX]; // 🌳 族谱图:并查集核心,存放每个节点的父节点

int size[MAX]; // 📊 规模表:存放每一个健康连通块里总共有多少个节点

// 集合一定只放普通点,病毒源头点根本不参数与集合,也不是元素

// ----------------------------- 初始化模块 -----------------------------

void build(int n, int *initial, int initialSize)
{
    for (int i = 0; i < n; i++)
    {
        virus[i] = false; // 🏗️ 初始化:先假设所有人都是健康的
        cnts[i] = 0;      // 🏗️ 初始化:所有病毒的拯救贡献初始为 0
        infect[i] = -1;   // 🏗️ 初始化:所有区域初始都是"未受威胁"状态
        size[i] = 1;      // 🏗️ 初始化:每个节点初始自成一派,大小为 1
        father[i] = i;    // 🏗️ 初始化:每个节点的祖先暂时都是自己
    }
    for (int i = 0; i < initialSize; i++)
    {
        virus[initial[i]] = true; // 🧪 确诊标记:根据输入名单,把真正的病毒节点标记出来
    }
}

// ----------------------------- 并查集核心模块 -----------------------------

int find(int i)
{
    if (i != father[i]) // 🔍 判断:如果我的父节点不是我自己,说明我上面还有"老大"
    {
        father[i] = find(father[i]); // 🚀 递归并路径压缩:直接认"最高祖先"当爹,提高以后查询速度
    }
    return father[i]; // 🎯 返回:最终找到的最顶层祖先(代表节点)
}

void do_union(int x, int y)
{
    int fx = find(x); // 📍 找到 x 所在团伙的最高负责人
    int fy = find(y); // 📍 找到 y 所在团伙的最高负责人
    if (fx != fy)     // 🤝 判断:如果两者的负责人不是同一个人,说明它们还不属于同一个团伙
    {
        father[fx] = fy;      // 🔗 合并:让 x 的负责人认 y 的负责人当老大,两个团伙合并
        size[fy] += size[fx]; // 📈 扩容:新团伙的总人数等于两个旧团伙人数之和
    }
}

// ----------------------------- 回调工具模块 -----------------------------

int int_cmp(const void *e1, const void *e2)
{
    return (*(int *)e1) - (*(int *)e2); // ⚖️ 比较规则:数值小的排前面,用于排序初始病毒数组
}

// ----------------------------- 主算法逻辑模块 -----------------------------

int minMalwareSpread(int **graph, int graphSize, int *graphColSize, int *initial, int initialSize)
{
    int n = graphSize;
    build(n, initial, initialSize); // 🏗️ 步骤1:搭建基础数据环境
    // 只要不是病毒,是普通点,该合并就去合并
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (graph[i][j] == 1 && !virus[i] && !virus[j]) // 🔗 判断:如果 i 和 j 有连线,且两个都不是病毒
            {
                do_union(i, j); // 🤝 合并:把这两个连通的健康人划入同一个"纯净区域"
            }
        }
    }

    // 病毒周围的普通点的那个集合去设置源头
    for (int i = 0, sick; i < initialSize; i++)
    {
        sick = initial[i]; // ☣️ 锁定:当前正在观察的这个初始病毒节点
        for (int neighbor = 0; neighbor < n; neighbor++)
        {
            if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1) // 📡 判断:如果是该病毒的邻居,且邻居是健康人
            {
                int fn = find(neighbor); // 📡 探测:找到这个健康邻居所属的整个"纯净区域"的老大
                if (infect[fn] == -1)    // 🛡️ 判断:如果这个纯净区域之前还没被任何病毒标记过
                {
                    infect[fn] = sick; // 🔍 记录:这是第一个发现能感染该区域的病毒
                }
                else if (infect[fn] != -2 && infect[fn] != sick) // ⚡ 判断:如果已经有其他病毒盯上这块区域了
                {
                    infect[fn] = -2; // 🛑 报废:多源感染,删掉一个也救不活它
                }
            }
        }
    }

    // 统计拯救数据  只讨论代表节点,因为代表节点存储这集合中的元素数量.
    for (int i = 0; i < n; i++)
    {
        if (i == find(i) && infect[i] >= 0) // 📈 判断:如果 i 是区域老大,且该区域只被唯一一个病毒威胁
        {
            cnts[infect[i]] += size[i]; // ✅ 记功:把这个区域的所有人数都算在该病毒的"拯救额度"里
        }
    }

    qsort(initial, initialSize, sizeof(initial[0]), int_cmp); // ⏱️ 步骤2:对病毒编号排序,方便查找最小值

    int ans = initial[0]; // 🏁 初始设定:默认第一个病毒为最终答案
    int max = cnts[ans];  // 📊 记录:当前最高能拯救的人数
    for (int i = 0; i < initialSize; i++)
    {
        if (cnts[initial[i]] > max) // 🏆 判断:如果发现另一个病毒移除后拯救效果更好
        {
            ans = initial[i];       // ✅ 更新:记录这个性价比更高的病毒编号
            max = cnts[initial[i]]; // 🚀 刷新:更新目前的最高纪录
        }
    }

    return ans; // 🚀 结果:返回最终方案
}