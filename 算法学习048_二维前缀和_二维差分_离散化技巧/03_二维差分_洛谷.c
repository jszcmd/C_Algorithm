/*
 * =============================================================
 * 题目名称：地毯 (加深版)
 * #### 测试链接: https://www.luogu.com.cn/problem/P3397
 * * 【题目描述】
 * 在一个 n * n 的正方形格子上，总共铺设了 m 块地毯。
 * 每一块地毯的信息都会给出:
 * - 左上角坐标 (x1, y1)
 * - 右下角坐标 (x2, y2)
 * * 现在的任务是：
 * 计算并输出每一个格子 (i, j) 到底被多少块地毯覆盖了.
 * * -------------------------------------------------------------
 * * 【输入格式】
 * 1. 第一行输入两个正整数 n 和 m。
 * - n: 格子的大小 (n * n)
 * - m: 地毯的数量
 * * 2. 接下来 m 行，每行输入 4 个整数: x1 y1 x2 y2
 * - 代表一块地毯覆盖的矩形区域.
 * - 左上角是 (x1, y1),右下角是 (x2, y2)。
 * * -------------------------------------------------------------
 * * 【输出格式】
 * 输出 n 行，每行有 n 个整数.
 * 第 i 行第 j 列的数字,代表坐标 (i, j) 这个点被覆盖的层数.
 * (数字之间用空格隔开)
 * * -------------------------------------------------------------
 * =============================================================
 */

/*
注意:int add(int a,int b,int c,int d)
    这里的(a,b)和(c,d)都是索引值.
    题目中的(x1,y1)和(x2,y2)都是第几行第几列. 我们就需要传入 (x1-1,y1-1)
    但是我们准备了一圈0来控制,所以就需要加一个1,结果还是传入(x1,y1)和(x2,y2)
 */

#include <stdio.h>
#include <string.h>

#define MAX 1002 // 定义最大容量,稍微开大一点防止越界

// 全局变量:差分数组/结果矩阵
// 未手动初始化时,全局变量默认全为 0
int arr[MAX][MAX];

int n; // 题目读入的矩阵大小 n*n
int m; // 读取操作次数

// 核心函数:二维差分更新
// 作用:在 (a, b) 到 (c, d) 的矩形范围内统一增加 v
// 原理:通过修改四个顶点的数值,在 O(1) 时间内完成标记
void add(int arr[MAX][MAX], int a, int b, int c, int d, int v)
{
    arr[a][b] += v;         // 左上角:开始增加
    arr[c + 1][b] -= v;     // 右上角的右侧:抵消横向影响
    arr[a][d + 1] -= v;     // 左下角的下方:抵消纵向影响
    arr[c + 1][d + 1] += v; // 右下角的右下方:因为上面减了两次,这里加回来
}

// 核心函数:构建二维前缀和
// 作用:将差分数组还原为最终的覆盖次数矩阵
void bulid()
{
    int i = 0;
    int j = 0;
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= n; j++)
        {
            // 二维前缀和递推公式：
            // 当前格的值 = 左格 + 上格 - 左上格 + 差分值
            arr[i][j] += arr[i][j - 1] + arr[i - 1][j] - arr[i - 1][j - 1];
        }
    }
}

// 清空数组函数
void clear()
{
    memset(arr, 0, sizeof(arr));
}

int main()
{
    // 读取矩阵大小 n 和操作次数 m
    if (scanf("%d %d", &n, &m) != 2)
        return 0;

    int a, b, c, d;
    int i = 0;
    int j = 0;

    // 循环处理 m 次地毯覆盖操作
    for (i = 0; i < m; i++)
    {
        scanf("%d %d %d %d", &a, &b, &c, &d);
        // 执行差分操作,每次覆盖权值 +1
        add(arr, a, b, c, d, 1);
    }

    // 计算前缀和,还原出每个格子被覆盖的真实次数
    bulid();

    // 遍历并输出结果矩阵
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= n; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n"); // 每一行输出完后换行
    }

    // 虽然程序即将结束,但保留清空操作
    clear();

    return 0;
}
