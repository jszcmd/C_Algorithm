/*
 * ================================================================================
 * 📘 题目: 按奇偶排序数组 II (Sort Array by Parity II)
 * 🔗 题目链接: https://leetcode.cn/problems/sort-array-by-parity-ii/
 * ================================================================================
 * 难度: 简单
 * 标签: 数组, 双指针
 *
 * 【题目描述】
 * 给定一个非负整数数组 nums,其中一半整数是 奇数 ,一半整数是 偶数 .
 * 对数组进行排序,以便当 nums[i] 为奇数时,i 也是奇数;当 nums[i] 为偶数时, i 也是偶数.
 *
 * --------------------------------------------------------------------------------
 * 🌟 示例 1:
 * 输入:nums = [4,2,5,7]
 * 输出:[4,5,2,7] (解释:[4,7,2,5], [2,5,4,7], [2,7,4,5] 也会被接受)
 *
 * 🌟 示例 2:
 * 输入:nums = [2,3]
 * 输出:[2,3]
 *
 * --------------------------------------------------------------------------------
 * 📏 提示 (Constraints):
 * • 2 <= nums.length <= 2 * 10^4
 * • nums.length 是偶数
 * • nums 中一半是偶数,一半是奇数
 * ================================================================================
 */

// 🛠️ 辅助函数:交换数组中两个元素的位置
void swap(int arr[], int a, int b)
{
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

/**
 * 🛰️ 核心逻辑:双指针原地交换
 * 利用数组最后一个元素作为"中转站",根据其奇偶性将其派发到正确的索引位置.
 */
int *sortArrayByParityII(int *nums, int numsSize, int *returnSize)
{
    int n = numsSize; // 数组的长度
    *returnSize = n;  // 设定返回数组的大小

    // 🏁 初始化双指针:even 指向偶数位(0,2,4...),odd 指向奇数位(1,3,5...)
    for (int odd = 1, even = 0; odd < n && even < n;)
    {
        // 🔍 检查数组末尾元素 nums[n-1] 的奇偶性
        if ((nums[n - 1] & 1) == 1)
        {
            swap(nums, odd, n - 1); // 🚩 如果末尾是奇数：将其交换到当前的奇数下标位 odd
            odd += 2;               // 奇数位填妥，指针向后移动两步
        }
        else
        {
            swap(nums, even, n - 1); // 🚩 如果末尾是偶数：将其交换到当前的偶数下标位 even
            even += 2;               // 偶数位填妥，指针向后移动两步
        }
    }

    // ✨ 返回处理后的原数组指针
    return nums;
}
