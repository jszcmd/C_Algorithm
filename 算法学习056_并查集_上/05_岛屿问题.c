/* =============================================================================
 * 题目编号:200. 岛屿数量 (Number of Islands)
 * 题目难度:中等 (Medium)
 * 题目链接:https://leetcode.cn/problems/number-of-islands/
 * -----------------------------------------------------------------------------
 * 【题目描述】
 * 给你一个由 '1' (陆地) 和 '0' (水) 组成的二维网格 grid,请你计算网格中岛屿的数量.
 * * 岛屿总是被水包围,并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成.
 * 此外,你可以假设该网格的四条边均被水包围.
 * * 【示例说明】
 * 示例 1:
 * 输入:grid = [
 * ["1","1","1","1","0"],
 * ["1","1","0","1","0"],
 * ["1","1","0","0","0"],
 * ["0","0","0","0","0"]
 * ]
 * 输出:1
 * * 示例 2:
 * 输入:grid = [
 * ["1","1","0","0","0"],
 * ["1","1","0","0","0"],
 * ["0","0","1","0","0"],
 * ["0","0","0","1","1"]
 * ]
 * 输出:3
 * * 【数据范围限制】
 * - m == grid.length
 * - n == grid[i].length
 * - 1 <= m, n <= 300
 * - grid[i][j] 的值为 '0' 或 '1'
 * =============================================================================
 */

/* ------------------ 全局配置与状态 ------------------ */

#define MAX 301       // 题目限制的最大行和列
char board[MAX][MAX]; // 备份原地图,方便在函数间直接访问
int cols;             // 记录地图的实际列数,用于二维转一维

#define MAXSIZE 90001 // 最大节点数 (300 * 300)
int father[MAXSIZE];  // 并查集的父节点数组
int sets;             // 记录当前集合(岛屿)的数量

/**
 * 坐标转换函数:将二维网格坐标 (a, b) 映射为一维数组下标
 * 公式:行索引 * 总列数 + 列索引
 */
int get_index(int a, int b)
{
    return a * cols + b;
}

/**
 * 并查集:查找根节点(含路径压缩优化)
 * 作用:找到元素 i 所属集合的"代表"
 */
int find(int i)
{
    if (i != father[i])
    {
        father[i] = find(father[i]); // 递归寻找根节点,并顺便把路径上的节点直接连到根上,提高后续查找效率
    }
    return father[i];
}

/**
 * 并查集:合并操作
 * 作用:如果 (a, b) 和 (c, d) 两个坐标都是陆地且相连,则将它们合并为一个集合
 */
void do_union(int a, int b, int c, int d)
{
    int fx = find(get_index(a, b));
    int fy = find(get_index(c, d));

    if (fx != fy) // 如果两者的根节点不同,说明它们原本属于不同岛屿,现在连通了
    {
        father[fx] = fy; // 执行合并
        sets--;          // 两个岛屿合并为一个,总岛屿数减 1
    }
}

/**
 * 主逻辑函数:计算岛屿数量
 */
int numIslands(char **grid, int gridSize, int *gridColSize)
{
    int n = gridSize;       // 获取总行数
    int m = gridColSize[0]; // 获取总列数
    cols = m;               // 初始化全局变量列数
    sets = 0;               // 初始化岛屿计数器

    // 第一步:初始化并查集
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            board[i][j] = grid[i][j]; // 将输入数据存入全局 board

            if (board[i][j] == '1') // 如果当前是陆地
            {
                int cur = get_index(i, j);
                father[cur] = cur; // 初始状态:每个陆地都是一个独立的岛屿(父节点是自己)
                sets++;            // 每发现一块陆地,暂且认为是一个独立岛屿
            }
        }
    }

    // 第二步:遍历地图,合并相邻的陆地
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (board[i][j] == '1')
            {
                // 只需要检查"左边"和"上边"的邻居
                // 因为我们是从左上往右下遍历,这样检查足以覆盖所有连接情况

                // 检查左邻居:j > 0 保证不越界
                if (j > 0 && board[i][j - 1] == '1')
                {
                    do_union(i, j, i, j - 1);
                }

                // 检查上邻居:i > 0 保证不越界
                if (i > 0 && board[i - 1][j] == '1')
                {
                    do_union(i, j, i - 1, j);
                }
            }
        }
    }

    // 最终剩下的集合数量就是独立的岛屿数量
    return sets;
}
