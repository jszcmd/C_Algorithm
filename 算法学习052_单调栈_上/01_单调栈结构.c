/*
* ================================================================================
 * 📘 题目: 单调栈 - 找左右最近的较小值
 * #### 测试链接:https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb
 * ================================================================================
 * 【题目描述】
 * 给定一个可能含有重复值的数组 arr,找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置.
 * 返回所有位置相应的信息.
 *
 * --------------------------------------------------------------------------------
 * 【输入描述】
 * 第一行输入一个数字 n,表示数组 arr 的长度.
 * 以下一行输入 n 个数字,表示数组的值.
 *
 * 【输出描述】
 * 输出 n 行,每行两个数字 L 和 R,如果不存在,则值为 -1,下标从 0 开始.
 *
 * --------------------------------------------------------------------------------
 * 🌟 示例:
 * 输入:
 * 7
 * 3 4 1 5 6 2 7
 *
 * 输出:
 * -1 2
 * 0 2
 * -1 -1
 * 2 5
 * 3 5
 * 2 -1
 * 5 -1
 *
 * --------------------------------------------------------------------------------
 * 📏 备注 (Constraints):
 * • 1 <= n <= 1000000
 * • -1000000 <= arr_i <= 1000000
 * ================================================================================
 */


#include <stdio.h> // 使用sacnf和printf函数

#define MAX 1000001 // 题目最大的数据量

int arr[MAX] = {0}; // 输入数据数组
int stack[MAX] = {0}; // 单调栈(存储下标, 对应的数值严格单调递增)
int ans[MAX][2] = {0}; // 结果数组: [i][0]左边最近更小, [i][1]右边最近更小
int n, r; // n:数组长度; r:栈顶指针(表示栈内元素个数)

void compute() {
    r = 0; // 重置栈
    int cur = 0;
    int i = 0;

    // --- 第一步: 遍历阶段 ---
    // 维护一个单调递增栈 (栈底 -> 栈顶: 小 -> 大)
    for (i = 0; i < n; i++) {
        // 关键点: arr[...] >= arr[i], 遇到相等或更小的值就弹出
        // 注: 遇到相等值也弹出, 会导致右侧答案暂时指向这个相等值(需要后续修正)
        while (r > 0 && arr[stack[r - 1]] >= arr[i]) {
            cur = stack[--r]; // 弹出栈顶

            // 左侧答案: 栈中剩下的那个元素(就是左边离它最近且比它小的)
            ans[cur][0] = (r > 0) ? stack[r - 1] : -1;
            // 右侧答案: 让你出栈的元素(暂时记录, 可能是相等值)
            ans[cur][1] = i;
        }
        stack[r++] = i; // 下标入栈
    }

    // --- 第二步: 清算阶段 ---
    // 栈中剩余的元素, 说明右边没有比它更小的数了
    while (r > 0) {
        cur = stack[--r];
        ans[cur][0] = (r > 0) ? stack[r - 1] : -1; // 左侧依然是栈底元素
        ans[cur][1] = -1; // 右侧一律为 -1
    }

    // --- 第三步: 修正阶段 ---
    // 针对重复值的逻辑修正:
    // 如果 ans[i][1] 指向的是一个数值相等的位置, 说明它不是"更小", 而是"相等"
    // 需要把那个相等位置的答案传递过来
    // 必须从右往左遍历, 保证右边的答案已经是修正过的
    for (i = n - 2; i >= 0; i--) {
        // 如果右侧有答案, 且右侧那个位置的值 == 当前值
        if (ans[i][1] != -1 && arr[ans[i][1]] == arr[i]) {
            ans[i][1] = ans[ans[i][1]][1]; // 传递/复制答案
        }
    }
}

int main() {
    // 读入数组长度
    if (scanf("%d", &n) != 1) return 0;

    int i = 0;
    // 读入数组内容
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // 核心计算
    compute();

    // 格式化输出
    for (i = 0; i < n; i++) {
        printf("%d %d\n", ans[i][0], ans[i][1]);
    }
    return 0;
}
