# 算法讲解060【必备】拓扑排序的扩展技巧

**讲师**：左程云

## 前置知识
1. **讲解041-同余原理**
2. **讲解059~讲解065**：都是【必备】课程有关图的内容，建议从头开始学习。

---

## 本节课内容

本节课继续讲解拓扑排序的题目。

### 重要技巧
**利用拓扑排序的过程，上游节点逐渐推送消息给下游节点的技巧。**

> **注意**：
> 这个技巧已经是树型 DP（动态规划）的内容了，不过即便不会动态规划，本节课也能听懂。
> 动态规划专题（包括树型 DP）会在后续【必备】课程里讲述。

---

## 题目1：最大食物链计数

### 题目描述
* `a -> b`，代表 `a` 在食物链中被 `b` 捕食。
* 给定一个有向无环图，返回这个图中从最初级动物到最顶级捕食者的食物链有几条。

### 注意事项
本题答案很大，需要取模。不了解的同学请参考“讲解041-同余原理”。

### 测试链接
[Luogu P4017](https://www.luogu.com.cn/problem/P4017)

``````c
/*
 * 题目:P4017 最大食物链计数
 * 来源:洛谷 (Luogu)
 * #### 测试连接: https://www.luogu.com.cn/problem/P4017
 *
 * 题目描述:
 * 给你一个食物网，你要求出这个食物网中最大食物链的数量。
 * (这里的"最大食物链",指的是生物学意义上的食物链,即最左端是不会捕食其他生物的生产者,
 * 最右端是不会被其他生物捕食的消费者.)
 *
 * 由于这个结果可能过大,你只需要输出总数模上 80112002 的结果.
 *
 * 输入格式:
 * 第一行,两个正整数 n、m,表示生物种类 n 和吃与被吃的关系数 m.
 * 接下来 m 行，每行两个正整数 A B,表示被吃的生物 A 和吃 A 的生物 B (即存在边 A -> B)。
 *
 * 输出格式:
 * 一行一个整数,为最大食物链数量模上 80112002 的结果.
 *
 * 数据范围:
 * 1 <= n <= 5000
 * 1 <= m <= 500000
 * 保证图中不会出现环(DAG).
 */

#include <stdio.h>  // 使用scanf()|printf()
#include <string.h> // 使用memset()

#define MAXN 5001    // 最大节点数 N
#define MAXM 500001  // 最大边数 M
#define MOD 80112002 // 结果取模,防止整数溢出,同时题目也要求取模

// 链式前向星建图变量
int head[MAXN]; // head[u] 存储节点 u 的第一条边的编号
int next[MAXM]; // next[e] 存储编号为 e 的边的"下一条"边编号
int to[MAXM];   // to[e] 存储编号为 e 的边的终点
int cnt;        // 边的计数器(给每条边分配唯一ID)
int n, m;       // n个节点, m条边

// 拓扑排序需要的队列
int queue[MAXN]; // 手写队列,比系统队列更快
int l, r;        // l: 队头指针, r: 队尾指针

// 入度表
int indegree[MAXN]; // 记录每个节点有多少条入边

// 向上推送的信息 (DP数组)
int lines[MAXN]; // lines[i] 表示从起点到节点 i 有多少条不同的路径

void build()
{
    cnt = 1;                               // 边编号从1开始,这样0就可以表示"没有边"
    memset(head, 0, sizeof(head));         // 初始化头指针数组
    memset(indegree, 0, sizeof(indegree)); // 清空入度表
    memset(lines, 0, sizeof(lines));       // 清空路径计数数组
}

void addChainEdge(int u, int v)
{
    next[cnt] = head[u]; // 新边的 next 指向旧的 head (头插法)
    to[cnt] = v;         // 记录这条边的终点是 v
    head[u] = cnt;       // 更新 u 的 head 为当前新边
    cnt++;               // 编号自增，为下一条边做准备
}

int ways()
{
    l = r = 0; // 初始化队列指针

    // 1. 初始化:找到所有入度为0的点(生产者)
    for (int i = 1; i <= n; i++)
    {
        if (indegree[i] == 0)
        {
            queue[r++] = i; // 入度为0,加入拓扑排序队列
            lines[i] = 1;   // 作为起点,自身算作 1 条路径
        }
    }

    int ans = 0; // 记录最终的总路径数

    // 2. 开始拓扑排序
    while (l < r)
    {
        int u = queue[l++]; // 弹出当前处理的节点 u
        if (head[u] == 0)   // 当前的u节点不再有后续邻居了
        {
            ans = (ans + lines[u]) % MOD; // 如果是终点,累加它的路径数到答案
        }
        else
        {
            for (int ei = head[u], v; ei > 0; ei = next[ei]) // 遍历 u 的所有邻居 v
            {
                v = to[ei];                             // 获取当前边的终点 v
                lines[v] = (lines[u] + lines[v]) % MOD; // 核心 DP 转移:把 u 的路径数加到 v 身上
                if (--indegree[v] == 0)                 // 拓扑排序逻辑:删掉 u->v 这条边 (v的入度减1)
                {
                    queue[r++] = v; // 如果 v 的所有前置节点都处理完了，入队
                }
            }
        }
    }
    return ans; // 返回统计好的路径总数
}

int main()
{
    scanf("%d %d", &n, &m); // 读取点数和边数
    build();                // 初始化建图环境
    for (int i = 0, u, v; i < m; i++)
    {
        scanf("%d %d", &u, &v); // 读取一条边 u -> v
        addChainEdge(u, v);     // 存入链式前向星
        indegree[v]++;          // 统计终点 v 的入度，用于拓扑排序
    }
    printf("%d", ways()); // 执行算法并输出结果
    return 0;
}
``````



---

## 题目2：喧闹和富有 (Loud and Rich)

### 题目描述
* 有一组人，从 `0` 到 `n - 1` 编号，其中每个人都有不同数目的钱，以及不同程度的安静值。
* 给你一个数组 `richer`，其中 `richer[i] = [ai, bi]` 表示 person `ai` 比 person `bi` 更有钱。
* 还有一个整数数组 `quiet`，其中 `quiet[i]` 是 person `i` 的安静值。
* `richer` 中所给出的数据逻辑自洽（即：在 `x` 比 `y` 更有钱的同时，不会出现 `y` 比 `x` 更有钱的情况）。

**目标**：
返回一个整数数组 `answer` 作为答案，其中 `answer[x] = y` 的前提是：
在所有拥有的钱 **肯定不少于** person `x` 的人中，person `y` 是 **最安静** 的人（也就是安静值 `quiet[y]` 最小的人）。

### 测试链接
[LeetCode 851](https://leetcode.cn/problems/loud-and-rich/)

``````c
/*
 * 题目:851. 喧闹和富有 (Loud and Rich)
 * 来源:LeetCode
 * #### 测试链接: https://leetcode.cn/problems/loud-and-rich/description/
 *
 * 题目描述:
 * 有一组 n 个人作为实验对象,从 0 到 n - 1 编号,其中每个人都有不同数目的钱,
 * 以及不同程度的安静值 (quietness).
 * * 给你一个数组 richer，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱.
 * 另给你一个整数数组 quiet,其中 quiet[i] 是 person i 的安静值.
 * richer 中所给出的数据 逻辑自洽 (也就是说,在 person x 比 person y 更有钱的同时,
 * 不会出现 person y 比 person x 更有钱的情况 ).
 *
 * 现在,返回一个整数数组 answer 作为答案,其中 answer[x] = y 的前提是:
 * 在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人(也就是安静值 quiet[y] 最小的人).
 *
 * 示例 1:
 * 输入:richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
 * 输出:[5,5,2,5,4,5,6,7]
 *
 * 提示:
 * n == quiet.length
 * 1 <= n <= 500
 * 0 <= quiet[i] < n
 * quiet 的所有值 互不相同
 * 0 <= richer.length <= n * (n - 1) / 2
 */

#include <stdio.h>  // 使用NULL;
#include <stdlib.h> // 使用malloc()函数
#include <string.h> // 使用memeset()函数
#define MAX 501     // 定义最大节点数,实际上我们0位置的也用

// 声明边的结构体:链表中的每一个节点代表一条边
struct EdgeNode
{
    int to;                // 这条边的终点节点编号
    struct EdgeNode *next; // 指向该起点引出的下一条边的指针
};

typedef struct EdgeNode EdgeNode; // 简化类型定义

EdgeNode *adjList[MAX]; // 邻接表全局变量:指针数组,数组的每个下标代表图的一个节点

// 初始化邻接表并释放内存
void build(int n)
{
    for (int i = 0; i <= n; i++) // 遍历每一个节点的边链表,0位置也使用(也要初始化)
    {
        EdgeNode *cur = adjList[i]; // cur 指向当前节点的链表头
        while (cur)                 // 循环直到链表末尾
        {
            EdgeNode *tmp = cur; // 暂存当前节点指针
            cur = cur->next;     // 指针后移到下一个边节点
            free(tmp);           // 释放当前动态申请的结构体内存
        }
        adjList[i] = NULL; // 将该节点的表头指针归零,防止野指针
    }
}

// 向图中添加一条单向边 (u -> v)
void addListEdge(int u, int v)
{
    EdgeNode *newNode = (EdgeNode *)malloc(sizeof(struct EdgeNode)); // 动态分配内存创建一个新的边节点
    newNode->to = v;                                                 // 设置边的终点

    // 采用"头插法",新节点插入到链表的最前端
    newNode->next = adjList[u]; // 新节点的 next 指向原来的表头
    adjList[u] = newNode;       // 更新表头为新加入的节点
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int *loudAndRich(int **richer, int richerSize, int *richerColSize, int *quiet, int quietSize, int *returnSize)
{
    // 1.初始化
    int n = quietSize;                     // 安静数组的长度,也是节点的个数
    build(n);                              // 初始化邻接表,必须先清空上一局的全局变量
    int indegree[n];                       // 入度表,C语言局部数组是垃圾值,必须手动清零
    memset(indegree, 0, sizeof(indegree)); // 初始化入读表为0.

    // 建表,添加边
    for (int i = 0, u, v; i < richerSize; i++)
    {
        u = richer[i][0];  // 起点
        v = richer[i][1];  // 终点
        addListEdge(u, v); // 添加边
        indegree[v]++;     // 终点的入度++
    }

    int queue[n];     // 拓扑排序需要队列
    int l = 0, r = 0; // 初始化队列

    // 搜集入度为0的点,收集到队列里面
    for (int i = 0; i < n; i++)
    {
        if (indegree[i] == 0) // 入度为0
            queue[r++] = i;   // 入队
    }

    int ans[n]; // 临时的局部的答案数组
    for (int i = 0; i < n; i++)
    {
        ans[i] = i; // 初始化:每个人最安静的人默认是自己
    }

    // 2.开始拓扑排序
    while (l < r)
    {
        int cur = queue[l++]; // 弹出入度为0的节点
        // 遍历cur的邻居
        EdgeNode *edge_ptr = adjList[cur];
        while (edge_ptr)
        {
            int nxt = edge_ptr->to;                // nxt 是 cur 的邻居(比cur钱少的人)
            if (quiet[ans[cur]] < quiet[ans[nxt]]) // 如果 [cur知道的最安静的人] 比 [nxt自己目前知道的] 还要安静
            {
                ans[nxt] = ans[cur]; // 那么nxt就更新答案,更新成cur的答案
            }
            if (--indegree[nxt] == 0) // 邻居的入度--
            {
                queue[r++] = nxt; // 邻居的入度为0,那么就入队
            }
            edge_ptr = edge_ptr->next; // 继续找下一个邻居
        }
    }

    // 3. 构造返回结果
    *returnSize = n;
    int *res = (int *)malloc(sizeof(int) * n); // 申请堆内存
    for (int i = 0; i < n; i++)
    {
        res[i] = ans[i]; // 把局部数组的数据拷贝到返回数组里
    }
    return res;
}
``````



---

## 题目3：并行课程 III (Parallel Courses III)

### 题目描述
* 给你一个整数 `n`，表示有 `n` 节课，课程编号从 `1` 到 `n`。
* 同时给你一个二维整数数组 `relations`，其中 `relations[j] = [prevCourse_j, nextCourse_j]` 表示课程 `prevCourse_j` 必须在课程 `nextCourse_j` 之前完成（先修课的关系）。
* 同时给你一个下标从 `0` 开始的整数数组 `time`，其中 `time[i]` 表示完成第 `(i+1)` 门课程需要花费的月份数。

**规则**：
1. 如果一门课的所有先修课都已经完成，你可以在 **任意** 时间开始这门课程。
2. 你可以 **同时** 上任意门课程。

**目标**：
请你返回完成所有课程所需要的 **最少** 月份数。
*(注意：测试数据保证一定可以完成所有课程，也就是先修课的关系构成一个有向无环图)*

### 测试链接
[LeetCode 2050](https://leetcode.cn/problems/parallel-courses-iii/)

``````c
/*
 * ======================================================================================
 * 题目:2050. 并行课程 III (Parallel Courses III)
 * 难度:困难 (Hard)
 * 来源:LeetCode
 * #### 测试链接: https://leetcode.cn/problems/parallel-courses-iii/
 *
 * 描述:
 * 给你一个整数 n ,表示有 n 节课,课程编号从 1 到 n .
 * 同时给你一个二维整数数组 relations ,其中 relations[j] = [prevCourse_j, nextCourse_j] ,
 * 表示课程 prevCourse_j 必须在课程 nextCourse_j 之前 完成(先修课的关系).
 * 同时给你一个下标从 0 开始的整数数组 time ,其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数.
 *
 * 请你根据以下规则算出完成所有课程所需要的 最少 月份数:
 * 1. 如果一门课的所有先修课都已经完成,你可以在 任意 时间开始这门课程.
 * 2. 你可以 同时 上 任意门课程 .
 *
 * 请你返回完成所有课程所需要的 最少 月份数.
 *
 * 注意:测试数据保证一定可以完成所有课程(也就是先修课的关系构成一个有向无环图).
 * ======================================================================================
 */

#include <string.h> // 使用memset()

#define MAXN 50001 // 最大节点数 N
#define MAXM 50001 // 最大边数 M

// 链式前向星建图变量
int head[MAXN]; // head[u] 存储节点 u 的第一条边的编号
int next[MAXM]; // next[e] 存储编号为 e 的边的"下一条"边编号
int to[MAXM];   // to[e] 存储编号为 e 的边的终点
int cnt;        // 边的计数器(给每条边分配唯一ID)

// 拓扑排序需要的队列
int queue[MAXN]; // 手写队列
int l, r;        // l: 队头指针, r: 队尾指针

// 入度表
int indegree[MAXN]; // 只使用下标 1到n ;0下标弃而不用

// cost[i]: 完成第i件事情,已经它之前的事情所用的时间.
int cost[MAXN]; // 完成工作耗用的时间;0下标弃而不用

void build()
{
    l = r = 0;                             // 队列初始化为0
    cnt = 1;                               // 边编号从1开始,这样0就可以表示"没有边"
    memset(head, 0, sizeof(head));         // 初始化头指针数组
    memset(indegree, 0, sizeof(indegree)); // 清空入度表
    memset(cost, 0, sizeof(cost));         // 清空花费表
}

void addChainEdge(int u, int v)
{
    next[cnt] = head[u]; // 新边的 next 指向旧的 head (头插法)
    to[cnt] = v;         // 记录这条边的终点是 v
    head[u] = cnt;       // 更新 u 的 head 为当前新边
    cnt++;               // 编号自增,为下一条边做准备
}

int minimumTime(int n, int **relations, int relationsSize, int *relationsColSize, int *time, int timeSize)
{
    // 节点的关系: [1,2,3,...,n] 节点是从1开始的 ; 一共有1...n这么多个节点
    // 时间time:  0下标: time[0] 代表1这件事完成的时间 依次类推
    // 也就是说 i号点的单点的时间花费要去 time[i-1]位置拿

    build(); // 初始化
    // 建图,添加边
    for (int i = 0, u, v; i < relationsSize; i++)
    {
        u = relations[i][0];
        v = relations[i][1];
        addChainEdge(u, v);
        indegree[v]++;
    }
    // 先遍历一遍,把入度为0的节点先加入到队列里面
    for (int i = 1; i <= n; i++)
    {
        if (indegree[i] == 0)
        {
            queue[r++] = i;
        }
    }
    // 开始拓扑排序主要逻辑
    while (l < r)
    {
        int cur = queue[l++]; // 弹出入度为0的节点,cur是节点编号
        // 在没有加之前是自己前面的事完成所需要的时间,加完之后就是自己这件事连同前面的事完成所需要的时间
        cost[cur] += time[cur - 1]; // 每一个点完成的时间先加自己的单点
        // 遍历邻居,给邻居推时间
        for (int ei = head[cur]; ei > 0; ei = next[ei])
        {
            int v = to[ei]; // v是cur节点的邻居的编号
            // 邻居之间有一个完成前面的事所需要的时间,更现在的这件事完成所需要的时间比,谁更大就维持谁
            cost[v] = (cost[v] > cost[cur]) ? cost[v] : cost[cur];
            if (--indegree[v] == 0) // 邻居的入度--
            {
                queue[r++] = v; // 如果v节点的入度变成0,进入队列.
            }
        }
    }
    // 遍历找所花费的最大时间
    int ans = 0;
    for (int i = 1; i <= n; i++) // 现在,cost[i]表示完成节点i以及i之前的事所需要的时间
    {
        ans = (ans > cost[i]) ? ans : cost[i];
    }
    return ans;
}

``````



---

## 题目4：参加会议的最多员工数 (Maximum Employees to Be Invited to a Meeting)

### 题目描述
* 一个公司准备组织一场会议，邀请名单上有 `n` 位员工。
* 公司准备了一张 **圆形** 的桌子，可以坐下 **任意数目** 的员工。
* 员工编号为 `0` 到 `n - 1`。每位员工都有一位 **喜欢** 的员工。
* 每位员工 **当且仅当** 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 **不会** 是他自己。
* 给你一个下标从 `0` 开始的整数数组 `favorite`，其中 `favorite[i]` 表示第 `i` 位员工喜欢的员工。

**目标**：
请你返回参加会议的 **最多员工数目**。

### 测试链接
[LeetCode 2127](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/)

``````c
/*
 * ======================================================================================
 * 题目:2127. 参加会议的最多员工数 (Maximum Employees to Be Invited to a Meeting)
 * #### 测试链接: https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/
 * 难度:困难 (Hard)
 * 来源:LeetCode
 * * 描述:
 * 一个公司准备组织一场会议,邀请名单上有 n 位员工。
 * 公司准备了一张 圆形 的桌子,可以坐下 任意数目 的员工.
 * * 员工编号为 0 到 n - 1 .每位员工都有一位 喜欢 的员工,每位员工 当且仅当 他被安排在喜欢员工的旁边,
 * 他才会参加会议.每位员工喜欢的员工 不会 是他自己.
 * * 给你一个下标从 0 开始的整数数组 favorite ,其中 favorite[i] 表示第 i 位员工喜欢的员工.
 * 请你返回参加会议的 最多员工数目.
 * ======================================================================================
 */

#include <string.h> // 使用memset()函数

int max(int a, int b)
{
    return (a > b) ? a : b;
}

int maximumInvitations(int *favorite, int favoriteSize)
{
    // favorite数组本身就可以代表图: favorite[a] = b: a->b
    int n = favoriteSize;
    int indegree[n];                       // 入度表
    memset(indegree, 0, sizeof(indegree)); // 入度表初始化为0
    // 先统计入度
    for (int i = 0; i < n; i++)
    {
        indegree[favorite[i]]++; // 如a->b,b的入度就++
    }
    int queue[n];     // 队列
    int l = 0, r = 0; // 队列初始化为0
    int deep[n];      // deep[i]不包括i在内,i之前的最长链的长度
    memset(deep, 0, sizeof(deep));

    // 先把入度为0的点加入到队列
    for (int i = 0; i < n; i++)
    {
        if (indegree[i] == 0)
        {
            queue[r++] = i; // 入度为0的节点入队列
        }
    }

    // 拓扑排序
    while (l < r)
    {
        int cur = queue[l++];                        // 弹出入度为0的人
        int next = favorite[cur];                    // cur喜欢的人(邻居)
        deep[next] = max(deep[next], deep[cur] + 1); // 维持最长链的长度
        if (--indegree[next] == 0)
        {
            queue[r++] = next; // 入度为0的节点入队列
        }
    }
    // 拓扑排序结束以后,目前,不在环上的点,都删除了!!! 不在环上面的节点i : indegree[i] = 0.
    // 可能性1: 所有小环(中心个数==2),算上中心点 + 延伸点  总个数
    int sumOfSmallRings = 0;
    // 可能性2: 所有大环(中心个数>2),只算中心点,最大环中心点个数
    int bigRings = 0;
    for (int i = 0; i < n; i++)
    {
        // 只关心环!!!
        if (indegree[i] > 0)
        {
            int ringSize = 1;
            indegree[i] = 0;
            for (int j = favorite[i]; j != i; j = favorite[j]) // j!=i,就一直绕圈
            {
                ringSize++;
                indegree[j] = 0; // 沿途把入度改成0,一个环只绕一次
            }
            if (ringSize == 2) // 遇到小环
            {
                sumOfSmallRings += 2 + deep[i] + deep[favorite[i]]; // 小环累加
            }
            else // 遇到大环
            {
                bigRings = max(bigRings, ringSize); // 大环取最大值
            }
        }
    }
    return max(sumOfSmallRings, bigRings); // 返回大环和小环的最大情况
}

``````

